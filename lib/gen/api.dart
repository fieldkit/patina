// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `add_or_update_station_in_portal`, `authenticate_portal`, `background_task`, `cache_firmware`, `calibrate`, `clear_calibration`, `configure`, `create_sdk`, `decoded`, `file_name`, `from`, `get_my_stations`, `get_nearby_addr`, `handle_background_message`, `new`, `new`, `open`, `refresh_token`, `refresh_tokens`, `register_portal_account`, `run`, `start_download`, `start_runtime`, `start_upload`, `upgrade_station`, `validate_tokens`, `verify_lora_transmission`, `with_runtime`
// These types are ignored because they are not used by any `pub` functions: `LogSink`, `MergeAndPublishReplies`, `RuntimeError`, `SdkMappingError`, `Sdk`, `StationAndConnection`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `flush`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `into`, `into`, `into`, `into`, `into`, `into`, `into`, `into`, `into`, `into`, `into`, `make_writer`, `try_into`, `try_into`, `write`

Stream<DomainMessage> startNative(
        {required String storagePath, required String portalBaseUrl}) =>
    RustLib.instance.api.crateApiStartNative(
        storagePath: storagePath, portalBaseUrl: portalBaseUrl);

Future<List<StationConfig>> getMyStations() =>
    RustLib.instance.api.crateApiGetMyStations();

Future<Authenticated> authenticatePortal(
        {required String email, required String password}) =>
    RustLib.instance.api
        .crateApiAuthenticatePortal(email: email, password: password);

Future<Registered> registerPortalAccount(
        {required String email,
        required String password,
        required String name,
        required bool tncAccount}) =>
    RustLib.instance.api.crateApiRegisterPortalAccount(
        email: email, password: password, name: name, tncAccount: tncAccount);

Future<int?> addOrUpdateStationInPortal(
        {required Tokens tokens, required AddOrUpdatePortalStation station}) =>
    RustLib.instance.api
        .crateApiAddOrUpdateStationInPortal(tokens: tokens, station: station);

Future<void> configureDeploy(
        {required String deviceId, required DeployConfig config}) =>
    RustLib.instance.api
        .crateApiConfigureDeploy(deviceId: deviceId, config: config);

Future<void> configureWifiNetworks(
        {required String deviceId, required WifiNetworksConfig config}) =>
    RustLib.instance.api
        .crateApiConfigureWifiNetworks(deviceId: deviceId, config: config);

Future<void> configureWifiTransmission(
        {required String deviceId, required WifiTransmissionConfig config}) =>
    RustLib.instance.api
        .crateApiConfigureWifiTransmission(deviceId: deviceId, config: config);

Future<void> configureLoraTransmission(
        {required String deviceId, required LoraTransmissionConfig config}) =>
    RustLib.instance.api
        .crateApiConfigureLoraTransmission(deviceId: deviceId, config: config);

Future<void> configureName(
        {required String deviceId, required NameConfig config}) =>
    RustLib.instance.api
        .crateApiConfigureName(deviceId: deviceId, config: config);

Future<void> verifyLoraTransmission({required String deviceId}) =>
    RustLib.instance.api.crateApiVerifyLoraTransmission(deviceId: deviceId);

Future<void> clearCalibration(
        {required String deviceId, required BigInt module}) =>
    RustLib.instance.api
        .crateApiClearCalibration(deviceId: deviceId, module: module);

Future<void> calibrate(
        {required String deviceId,
        required BigInt module,
        required List<int> data}) =>
    RustLib.instance.api
        .crateApiCalibrate(deviceId: deviceId, module: module, data: data);

Future<Authenticated> validateTokens({required Tokens tokens}) =>
    RustLib.instance.api.crateApiValidateTokens(tokens: tokens);

Future<TransferProgress> startDownload(
        {required String deviceId, BigInt? first}) =>
    RustLib.instance.api
        .crateApiStartDownload(deviceId: deviceId, first: first);

Future<TransferProgress> startUpload(
        {required String deviceId,
        required Tokens tokens,
        required List<RecordArchive> files}) =>
    RustLib.instance.api
        .crateApiStartUpload(deviceId: deviceId, tokens: tokens, files: files);

Future<FirmwareDownloadStatus> cacheFirmware(
        {Tokens? tokens, required bool background}) =>
    RustLib.instance.api
        .crateApiCacheFirmware(tokens: tokens, background: background);

Future<UpgradeProgress> upgradeStation(
        {required String deviceId,
        required LocalFirmware firmware,
        required bool swap}) =>
    RustLib.instance.api.crateApiUpgradeStation(
        deviceId: deviceId, firmware: firmware, swap: swap);

Future<bool> rustReleaseMode() =>
    RustLib.instance.api.crateApiRustReleaseMode();

Stream<String> createLogSink() => RustLib.instance.api.crateApiCreateLogSink();

class AddOrUpdatePortalStation {
  final String name;
  final String deviceId;
  final String locationName;
  final String statusPb;

  const AddOrUpdatePortalStation({
    required this.name,
    required this.deviceId,
    required this.locationName,
    required this.statusPb,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      deviceId.hashCode ^
      locationName.hashCode ^
      statusPb.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddOrUpdatePortalStation &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          deviceId == other.deviceId &&
          locationName == other.locationName &&
          statusPb == other.statusPb;
}

class Authenticated {
  final String email;
  final String name;
  final Tokens tokens;

  const Authenticated({
    required this.email,
    required this.name,
    required this.tokens,
  });

  @override
  int get hashCode => email.hashCode ^ name.hashCode ^ tokens.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Authenticated &&
          runtimeType == other.runtimeType &&
          email == other.email &&
          name == other.name &&
          tokens == other.tokens;
}

class BatteryInfo {
  final double percentage;
  final double voltage;

  const BatteryInfo({
    required this.percentage,
    required this.voltage,
  });

  @override
  int get hashCode => percentage.hashCode ^ voltage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BatteryInfo &&
          runtimeType == other.runtimeType &&
          percentage == other.percentage &&
          voltage == other.voltage;
}

class DeployConfig {
  final String location;
  final BigInt deployed;
  final Schedule schedule;

  const DeployConfig({
    required this.location,
    required this.deployed,
    required this.schedule,
  });

  @override
  int get hashCode => location.hashCode ^ deployed.hashCode ^ schedule.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DeployConfig &&
          runtimeType == other.runtimeType &&
          location == other.location &&
          deployed == other.deployed &&
          schedule == other.schedule;
}

class DeploymentConfig {
  final BigInt startTime;

  const DeploymentConfig({
    required this.startTime,
  });

  @override
  int get hashCode => startTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DeploymentConfig &&
          runtimeType == other.runtimeType &&
          startTime == other.startTime;
}

class DeviceCapabilities {
  final bool udp;

  const DeviceCapabilities({
    required this.udp,
  });

  @override
  int get hashCode => udp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DeviceCapabilities &&
          runtimeType == other.runtimeType &&
          udp == other.udp;
}

@freezed
sealed class DomainMessage with _$DomainMessage {
  const DomainMessage._();

  const factory DomainMessage.preAccount() = DomainMessage_PreAccount;
  const factory DomainMessage.nearbyStations(
    List<NearbyStation> field0,
  ) = DomainMessage_NearbyStations;
  const factory DomainMessage.stationRefreshed(
    StationConfig field0,
    EphemeralConfig? field1,
    String field2,
  ) = DomainMessage_StationRefreshed;
  const factory DomainMessage.uploadProgress(
    TransferProgress field0,
  ) = DomainMessage_UploadProgress;
  const factory DomainMessage.downloadProgress(
    TransferProgress field0,
  ) = DomainMessage_DownloadProgress;
  const factory DomainMessage.firmwareDownloadStatus(
    FirmwareDownloadStatus field0,
  ) = DomainMessage_FirmwareDownloadStatus;
  const factory DomainMessage.upgradeProgress(
    UpgradeProgress field0,
  ) = DomainMessage_UpgradeProgress;
  const factory DomainMessage.availableFirmware(
    List<LocalFirmware> field0,
  ) = DomainMessage_AvailableFirmware;
  const factory DomainMessage.recordArchives(
    List<RecordArchive> field0,
  ) = DomainMessage_RecordArchives;
}

class DownloadProgress {
  final BigInt started;
  final double completed;
  final BigInt total;
  final BigInt received;

  const DownloadProgress({
    required this.started,
    required this.completed,
    required this.total,
    required this.received,
  });

  @override
  int get hashCode =>
      started.hashCode ^
      completed.hashCode ^
      total.hashCode ^
      received.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DownloadProgress &&
          runtimeType == other.runtimeType &&
          started == other.started &&
          completed == other.completed &&
          total == other.total &&
          received == other.received;
}

class EphemeralConfig {
  final UtcDateTime queried;
  final DeploymentConfig? deployment;
  final TransmissionConfig? transmission;
  final List<NetworkConfig> networks;
  final LoraConfig? lora;
  final DeviceCapabilities capabilities;
  final Uint8List events;

  const EphemeralConfig({
    required this.queried,
    this.deployment,
    this.transmission,
    required this.networks,
    this.lora,
    required this.capabilities,
    required this.events,
  });

  @override
  int get hashCode =>
      queried.hashCode ^
      deployment.hashCode ^
      transmission.hashCode ^
      networks.hashCode ^
      lora.hashCode ^
      capabilities.hashCode ^
      events.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EphemeralConfig &&
          runtimeType == other.runtimeType &&
          queried == other.queried &&
          deployment == other.deployment &&
          transmission == other.transmission &&
          networks == other.networks &&
          lora == other.lora &&
          capabilities == other.capabilities &&
          events == other.events;
}

@freezed
sealed class FirmwareDownloadStatus with _$FirmwareDownloadStatus {
  const FirmwareDownloadStatus._();

  const factory FirmwareDownloadStatus.checking() =
      FirmwareDownloadStatus_Checking;
  const factory FirmwareDownloadStatus.downloading(
    DownloadProgress field0,
  ) = FirmwareDownloadStatus_Downloading;
  const factory FirmwareDownloadStatus.offline() =
      FirmwareDownloadStatus_Offline;
  const factory FirmwareDownloadStatus.completed() =
      FirmwareDownloadStatus_Completed;
  const factory FirmwareDownloadStatus.failed() = FirmwareDownloadStatus_Failed;
}

class FirmwareInfo {
  final String label;
  final PlatformInt64 time;

  const FirmwareInfo({
    required this.label,
    required this.time,
  });

  @override
  int get hashCode => label.hashCode ^ time.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FirmwareInfo &&
          runtimeType == other.runtimeType &&
          label == other.label &&
          time == other.time;
}

class LocalFirmware {
  final PlatformInt64 id;
  final String label;
  final PlatformInt64 time;
  final String module;
  final String profile;

  const LocalFirmware({
    required this.id,
    required this.label,
    required this.time,
    required this.module,
    required this.profile,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      label.hashCode ^
      time.hashCode ^
      module.hashCode ^
      profile.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LocalFirmware &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          label == other.label &&
          time == other.time &&
          module == other.module &&
          profile == other.profile;
}

enum LoraBand {
  f915Mhz,
  f868Mhz,
  ;
}

class LoraConfig {
  final bool available;
  final LoraBand band;
  final Uint8List deviceEui;
  final Uint8List appKey;
  final Uint8List joinEui;
  final Uint8List deviceAddress;
  final Uint8List networkSessionKey;
  final Uint8List appSessionKey;

  const LoraConfig({
    required this.available,
    required this.band,
    required this.deviceEui,
    required this.appKey,
    required this.joinEui,
    required this.deviceAddress,
    required this.networkSessionKey,
    required this.appSessionKey,
  });

  @override
  int get hashCode =>
      available.hashCode ^
      band.hashCode ^
      deviceEui.hashCode ^
      appKey.hashCode ^
      joinEui.hashCode ^
      deviceAddress.hashCode ^
      networkSessionKey.hashCode ^
      appSessionKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LoraConfig &&
          runtimeType == other.runtimeType &&
          available == other.available &&
          band == other.band &&
          deviceEui == other.deviceEui &&
          appKey == other.appKey &&
          joinEui == other.joinEui &&
          deviceAddress == other.deviceAddress &&
          networkSessionKey == other.networkSessionKey &&
          appSessionKey == other.appSessionKey;
}

class LoraTransmissionConfig {
  final int? band;
  final Uint8List? appKey;
  final Uint8List? joinEui;
  final Schedule? schedule;

  const LoraTransmissionConfig({
    this.band,
    this.appKey,
    this.joinEui,
    this.schedule,
  });

  @override
  int get hashCode =>
      band.hashCode ^ appKey.hashCode ^ joinEui.hashCode ^ schedule.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LoraTransmissionConfig &&
          runtimeType == other.runtimeType &&
          band == other.band &&
          appKey == other.appKey &&
          joinEui == other.joinEui &&
          schedule == other.schedule;
}

class ModuleConfig {
  final int position;
  final bool internal;
  final String moduleId;
  final String key;
  final List<SensorConfig> sensors;
  final Uint8List? configuration;

  const ModuleConfig({
    required this.position,
    required this.internal,
    required this.moduleId,
    required this.key,
    required this.sensors,
    this.configuration,
  });

  @override
  int get hashCode =>
      position.hashCode ^
      internal.hashCode ^
      moduleId.hashCode ^
      key.hashCode ^
      sensors.hashCode ^
      configuration.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ModuleConfig &&
          runtimeType == other.runtimeType &&
          position == other.position &&
          internal == other.internal &&
          moduleId == other.moduleId &&
          key == other.key &&
          sensors == other.sensors &&
          configuration == other.configuration;
}

class NameConfig {
  final String name;

  const NameConfig({
    required this.name,
  });

  @override
  int get hashCode => name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NameConfig &&
          runtimeType == other.runtimeType &&
          name == other.name;
}

class NearbyStation {
  final String deviceId;
  final bool busy;

  const NearbyStation({
    required this.deviceId,
    required this.busy,
  });

  @override
  int get hashCode => deviceId.hashCode ^ busy.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NearbyStation &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          busy == other.busy;
}

class NetworkConfig {
  final BigInt index;
  final String ssid;
  final bool preferred;

  const NetworkConfig({
    required this.index,
    required this.ssid,
    required this.preferred,
  });

  @override
  int get hashCode => index.hashCode ^ ssid.hashCode ^ preferred.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkConfig &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          ssid == other.ssid &&
          preferred == other.preferred;
}

@freezed
sealed class PortalError with _$PortalError implements FrbException {
  const PortalError._();

  const factory PortalError.authentication() = PortalError_Authentication;
  const factory PortalError.connecting() = PortalError_Connecting;
  const factory PortalError.other(
    String field0,
  ) = PortalError_Other;
  const factory PortalError.sdk() = PortalError_Sdk;
}

class RecordArchive {
  final String deviceId;
  final String generationId;
  final String path;
  final PlatformInt64 head;
  final PlatformInt64 tail;
  final PlatformInt64? uploaded;

  const RecordArchive({
    required this.deviceId,
    required this.generationId,
    required this.path,
    required this.head,
    required this.tail,
    this.uploaded,
  });

  @override
  int get hashCode =>
      deviceId.hashCode ^
      generationId.hashCode ^
      path.hashCode ^
      head.hashCode ^
      tail.hashCode ^
      uploaded.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RecordArchive &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          generationId == other.generationId &&
          path == other.path &&
          head == other.head &&
          tail == other.tail &&
          uploaded == other.uploaded;
}

class Registered {
  final String email;
  final String name;

  const Registered({
    required this.email,
    required this.name,
  });

  @override
  int get hashCode => email.hashCode ^ name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Registered &&
          runtimeType == other.runtimeType &&
          email == other.email &&
          name == other.name;
}

@freezed
sealed class Schedule with _$Schedule {
  const Schedule._();

  const factory Schedule.every(
    int field0,
  ) = Schedule_Every;
}

class SensorConfig {
  final int number;
  final bool internal;
  final String key;
  final String fullKey;
  final String calibratedUom;
  final String uncalibratedUom;
  final SensorValue? value;
  final SensorValue? previousValue;

  const SensorConfig({
    required this.number,
    required this.internal,
    required this.key,
    required this.fullKey,
    required this.calibratedUom,
    required this.uncalibratedUom,
    this.value,
    this.previousValue,
  });

  @override
  int get hashCode =>
      number.hashCode ^
      internal.hashCode ^
      key.hashCode ^
      fullKey.hashCode ^
      calibratedUom.hashCode ^
      uncalibratedUom.hashCode ^
      value.hashCode ^
      previousValue.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SensorConfig &&
          runtimeType == other.runtimeType &&
          number == other.number &&
          internal == other.internal &&
          key == other.key &&
          fullKey == other.fullKey &&
          calibratedUom == other.calibratedUom &&
          uncalibratedUom == other.uncalibratedUom &&
          value == other.value &&
          previousValue == other.previousValue;
}

class SensorValue {
  final UtcDateTime time;
  final double value;
  final double uncalibrated;

  const SensorValue({
    required this.time,
    required this.value,
    required this.uncalibrated,
  });

  @override
  int get hashCode => time.hashCode ^ value.hashCode ^ uncalibrated.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SensorValue &&
          runtimeType == other.runtimeType &&
          time == other.time &&
          value == other.value &&
          uncalibrated == other.uncalibrated;
}

class SolarInfo {
  final double voltage;

  const SolarInfo({
    required this.voltage,
  });

  @override
  int get hashCode => voltage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SolarInfo &&
          runtimeType == other.runtimeType &&
          voltage == other.voltage;
}

class StationConfig {
  final String deviceId;
  final String generationId;
  final String name;
  final FirmwareInfo firmware;
  final UtcDateTime lastSeen;
  final StreamInfo meta;
  final StreamInfo data;
  final BatteryInfo battery;
  final SolarInfo solar;
  final Uint8List? pb;
  final List<ModuleConfig> modules;

  const StationConfig({
    required this.deviceId,
    required this.generationId,
    required this.name,
    required this.firmware,
    required this.lastSeen,
    required this.meta,
    required this.data,
    required this.battery,
    required this.solar,
    this.pb,
    required this.modules,
  });

  @override
  int get hashCode =>
      deviceId.hashCode ^
      generationId.hashCode ^
      name.hashCode ^
      firmware.hashCode ^
      lastSeen.hashCode ^
      meta.hashCode ^
      data.hashCode ^
      battery.hashCode ^
      solar.hashCode ^
      pb.hashCode ^
      modules.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StationConfig &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          generationId == other.generationId &&
          name == other.name &&
          firmware == other.firmware &&
          lastSeen == other.lastSeen &&
          meta == other.meta &&
          data == other.data &&
          battery == other.battery &&
          solar == other.solar &&
          pb == other.pb &&
          modules == other.modules;
}

class StreamInfo {
  final BigInt size;
  final BigInt records;

  const StreamInfo({
    required this.size,
    required this.records,
  });

  @override
  int get hashCode => size.hashCode ^ records.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StreamInfo &&
          runtimeType == other.runtimeType &&
          size == other.size &&
          records == other.records;
}

class Tokens {
  final String token;
  final TransmissionToken transmission;

  const Tokens({
    required this.token,
    required this.transmission,
  });

  @override
  int get hashCode => token.hashCode ^ transmission.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Tokens &&
          runtimeType == other.runtimeType &&
          token == other.token &&
          transmission == other.transmission;
}

class TransferProgress {
  final String deviceId;
  final TransferStatus status;

  const TransferProgress({
    required this.deviceId,
    required this.status,
  });

  @override
  int get hashCode => deviceId.hashCode ^ status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransferProgress &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          status == other.status;
}

@freezed
sealed class TransferStatus with _$TransferStatus {
  const TransferStatus._();

  const factory TransferStatus.starting() = TransferStatus_Starting;
  const factory TransferStatus.downloading(
    DownloadProgress field0,
  ) = TransferStatus_Downloading;
  const factory TransferStatus.uploading(
    UploadProgress field0,
  ) = TransferStatus_Uploading;
  const factory TransferStatus.processing() = TransferStatus_Processing;
  const factory TransferStatus.completed() = TransferStatus_Completed;
  const factory TransferStatus.failed() = TransferStatus_Failed;
}

class TransmissionConfig {
  final bool enabled;

  const TransmissionConfig({
    required this.enabled,
  });

  @override
  int get hashCode => enabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransmissionConfig &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled;
}

class TransmissionToken {
  final String token;
  final String url;

  const TransmissionToken({
    required this.token,
    required this.url,
  });

  @override
  int get hashCode => token.hashCode ^ url.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransmissionToken &&
          runtimeType == other.runtimeType &&
          token == other.token &&
          url == other.url;
}

enum UpgradeError {
  other,
  sdCard,
  ;
}

class UpgradeProgress {
  final String deviceId;
  final PlatformInt64 firmwareId;
  final UpgradeStatus status;

  const UpgradeProgress({
    required this.deviceId,
    required this.firmwareId,
    required this.status,
  });

  @override
  int get hashCode => deviceId.hashCode ^ firmwareId.hashCode ^ status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UpgradeProgress &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          firmwareId == other.firmwareId &&
          status == other.status;
}

@freezed
sealed class UpgradeStatus with _$UpgradeStatus {
  const UpgradeStatus._();

  const factory UpgradeStatus.starting() = UpgradeStatus_Starting;
  const factory UpgradeStatus.uploading(
    UploadProgress field0,
  ) = UpgradeStatus_Uploading;
  const factory UpgradeStatus.restarting() = UpgradeStatus_Restarting;
  const factory UpgradeStatus.reconnectTimeout() =
      UpgradeStatus_ReconnectTimeout;
  const factory UpgradeStatus.completed() = UpgradeStatus_Completed;
  const factory UpgradeStatus.failed([
    UpgradeError? field0,
  ]) = UpgradeStatus_Failed;
}

class UploadProgress {
  final BigInt bytesUploaded;
  final BigInt totalBytes;

  const UploadProgress({
    required this.bytesUploaded,
    required this.totalBytes,
  });

  @override
  int get hashCode => bytesUploaded.hashCode ^ totalBytes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UploadProgress &&
          runtimeType == other.runtimeType &&
          bytesUploaded == other.bytesUploaded &&
          totalBytes == other.totalBytes;
}

class UtcDateTime {
  final PlatformInt64 field0;

  const UtcDateTime({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UtcDateTime &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class WifiNetworkConfig {
  final BigInt index;
  final String? ssid;
  final String? password;
  final bool preferred;
  final bool keeping;

  const WifiNetworkConfig({
    required this.index,
    this.ssid,
    this.password,
    required this.preferred,
    required this.keeping,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      ssid.hashCode ^
      password.hashCode ^
      preferred.hashCode ^
      keeping.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WifiNetworkConfig &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          ssid == other.ssid &&
          password == other.password &&
          preferred == other.preferred &&
          keeping == other.keeping;
}

class WifiNetworksConfig {
  final List<WifiNetworkConfig> networks;

  const WifiNetworksConfig({
    required this.networks,
  });

  @override
  int get hashCode => networks.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WifiNetworksConfig &&
          runtimeType == other.runtimeType &&
          networks == other.networks;
}

class WifiTransmissionConfig {
  final Tokens? tokens;
  final Schedule? schedule;

  const WifiTransmissionConfig({
    this.tokens,
    this.schedule,
  });

  @override
  int get hashCode => tokens.hashCode ^ schedule.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WifiTransmissionConfig &&
          runtimeType == other.runtimeType &&
          tokens == other.tokens &&
          schedule == other.schedule;
}
