// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.28.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.28';

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_fk',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<int?> addOrUpdateStationInPortal(
      {required Tokens tokens,
      required AddOrUpdatePortalStation station,
      dynamic hint});

  Future<Authenticated> authenticatePortal(
      {required String email, required String password, dynamic hint});

  Future<FirmwareDownloadStatus> cacheFirmware(
      {Tokens? tokens, required bool background, dynamic hint});

  Future<void> calibrate(
      {required String deviceId,
      required int module,
      required List<int> data,
      dynamic hint});

  Future<void> clearCalibration(
      {required String deviceId, required int module, dynamic hint});

  Future<void> configureDeploy(
      {required String deviceId, required DeployConfig config, dynamic hint});

  Future<void> configureLoraTransmission(
      {required String deviceId,
      required LoraTransmissionConfig config,
      dynamic hint});

  Future<void> configureName(
      {required String deviceId, required NameConfig config, dynamic hint});

  Future<void> configureWifiNetworks(
      {required String deviceId,
      required WifiNetworksConfig config,
      dynamic hint});

  Future<void> configureWifiTransmission(
      {required String deviceId,
      required WifiTransmissionConfig config,
      dynamic hint});

  Stream<String> createLogSink({dynamic hint});

  Future<List<StationConfig>> getMyStations({dynamic hint});

  Future<Registered> registerPortalAccount(
      {required String email,
      required String password,
      required String name,
      required bool tncAccount,
      dynamic hint});

  Future<bool> rustReleaseMode({dynamic hint});

  Future<TransferProgress> startDownload(
      {required String deviceId, int? first, dynamic hint});

  Stream<DomainMessage> startNative(
      {required String storagePath,
      required String portalBaseUrl,
      dynamic hint});

  Future<TransferProgress> startUpload(
      {required String deviceId,
      required Tokens tokens,
      required List<RecordArchive> files,
      dynamic hint});

  Future<UpgradeProgress> upgradeStation(
      {required String deviceId,
      required LocalFirmware firmware,
      required bool swap,
      dynamic hint});

  Future<Authenticated> validateTokens({required Tokens tokens, dynamic hint});

  Future<void> verifyLoraTransmission({required String deviceId, dynamic hint});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<int?> addOrUpdateStationInPortal(
      {required Tokens tokens,
      required AddOrUpdatePortalStation station,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_tokens(tokens, serializer);
        sse_encode_box_autoadd_add_or_update_portal_station(
            station, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_32,
        decodeErrorData: sse_decode_portal_error,
      ),
      constMeta: kAddOrUpdateStationInPortalConstMeta,
      argValues: [tokens, station],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddOrUpdateStationInPortalConstMeta => const TaskConstMeta(
        debugName: "add_or_update_station_in_portal",
        argNames: ["tokens", "station"],
      );

  @override
  Future<Authenticated> authenticatePortal(
      {required String email, required String password, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(email, serializer);
        sse_encode_String(password, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_authenticated,
        decodeErrorData: sse_decode_portal_error,
      ),
      constMeta: kAuthenticatePortalConstMeta,
      argValues: [email, password],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAuthenticatePortalConstMeta => const TaskConstMeta(
        debugName: "authenticate_portal",
        argNames: ["email", "password"],
      );

  @override
  Future<FirmwareDownloadStatus> cacheFirmware(
      {Tokens? tokens, required bool background, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_opt_box_autoadd_tokens(tokens, serializer);
        sse_encode_bool(background, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_firmware_download_status,
        decodeErrorData: sse_decode_portal_error,
      ),
      constMeta: kCacheFirmwareConstMeta,
      argValues: [tokens, background],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kCacheFirmwareConstMeta => const TaskConstMeta(
        debugName: "cache_firmware",
        argNames: ["tokens", "background"],
      );

  @override
  Future<void> calibrate(
      {required String deviceId,
      required int module,
      required List<int> data,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        sse_encode_usize(module, serializer);
        sse_encode_list_prim_u_8_loose(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCalibrateConstMeta,
      argValues: [deviceId, module, data],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kCalibrateConstMeta => const TaskConstMeta(
        debugName: "calibrate",
        argNames: ["deviceId", "module", "data"],
      );

  @override
  Future<void> clearCalibration(
      {required String deviceId, required int module, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        sse_encode_usize(module, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kClearCalibrationConstMeta,
      argValues: [deviceId, module],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kClearCalibrationConstMeta => const TaskConstMeta(
        debugName: "clear_calibration",
        argNames: ["deviceId", "module"],
      );

  @override
  Future<void> configureDeploy(
      {required String deviceId, required DeployConfig config, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        sse_encode_box_autoadd_deploy_config(config, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kConfigureDeployConstMeta,
      argValues: [deviceId, config],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kConfigureDeployConstMeta => const TaskConstMeta(
        debugName: "configure_deploy",
        argNames: ["deviceId", "config"],
      );

  @override
  Future<void> configureLoraTransmission(
      {required String deviceId,
      required LoraTransmissionConfig config,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        sse_encode_box_autoadd_lora_transmission_config(config, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kConfigureLoraTransmissionConstMeta,
      argValues: [deviceId, config],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kConfigureLoraTransmissionConstMeta => const TaskConstMeta(
        debugName: "configure_lora_transmission",
        argNames: ["deviceId", "config"],
      );

  @override
  Future<void> configureName(
      {required String deviceId, required NameConfig config, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        sse_encode_box_autoadd_name_config(config, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kConfigureNameConstMeta,
      argValues: [deviceId, config],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kConfigureNameConstMeta => const TaskConstMeta(
        debugName: "configure_name",
        argNames: ["deviceId", "config"],
      );

  @override
  Future<void> configureWifiNetworks(
      {required String deviceId,
      required WifiNetworksConfig config,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        sse_encode_box_autoadd_wifi_networks_config(config, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kConfigureWifiNetworksConstMeta,
      argValues: [deviceId, config],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kConfigureWifiNetworksConstMeta => const TaskConstMeta(
        debugName: "configure_wifi_networks",
        argNames: ["deviceId", "config"],
      );

  @override
  Future<void> configureWifiTransmission(
      {required String deviceId,
      required WifiTransmissionConfig config,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        sse_encode_box_autoadd_wifi_transmission_config(config, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kConfigureWifiTransmissionConstMeta,
      argValues: [deviceId, config],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kConfigureWifiTransmissionConstMeta => const TaskConstMeta(
        debugName: "configure_wifi_transmission",
        argNames: ["deviceId", "config"],
      );

  @override
  Stream<String> createLogSink({dynamic hint}) {
    return handler.executeStream(StreamTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCreateLogSinkConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kCreateLogSinkConstMeta => const TaskConstMeta(
        debugName: "create_log_sink",
        argNames: [],
      );

  @override
  Future<List<StationConfig>> getMyStations({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_station_config,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kGetMyStationsConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetMyStationsConstMeta => const TaskConstMeta(
        debugName: "get_my_stations",
        argNames: [],
      );

  @override
  Future<Registered> registerPortalAccount(
      {required String email,
      required String password,
      required String name,
      required bool tncAccount,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(email, serializer);
        sse_encode_String(password, serializer);
        sse_encode_String(name, serializer);
        sse_encode_bool(tncAccount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_registered,
        decodeErrorData: sse_decode_portal_error,
      ),
      constMeta: kRegisterPortalAccountConstMeta,
      argValues: [email, password, name, tncAccount],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kRegisterPortalAccountConstMeta => const TaskConstMeta(
        debugName: "register_portal_account",
        argNames: ["email", "password", "name", "tncAccount"],
      );

  @override
  Future<bool> rustReleaseMode({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRustReleaseModeConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kRustReleaseModeConstMeta => const TaskConstMeta(
        debugName: "rust_release_mode",
        argNames: [],
      );

  @override
  Future<TransferProgress> startDownload(
      {required String deviceId, int? first, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        sse_encode_opt_box_autoadd_u_64(first, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_transfer_progress,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kStartDownloadConstMeta,
      argValues: [deviceId, first],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kStartDownloadConstMeta => const TaskConstMeta(
        debugName: "start_download",
        argNames: ["deviceId", "first"],
      );

  @override
  Stream<DomainMessage> startNative(
      {required String storagePath,
      required String portalBaseUrl,
      dynamic hint}) {
    return handler.executeStream(StreamTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(storagePath, serializer);
        sse_encode_String(portalBaseUrl, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_domain_message,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kStartNativeConstMeta,
      argValues: [storagePath, portalBaseUrl],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kStartNativeConstMeta => const TaskConstMeta(
        debugName: "start_native",
        argNames: ["storagePath", "portalBaseUrl"],
      );

  @override
  Future<TransferProgress> startUpload(
      {required String deviceId,
      required Tokens tokens,
      required List<RecordArchive> files,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        sse_encode_box_autoadd_tokens(tokens, serializer);
        sse_encode_list_record_archive(files, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_transfer_progress,
        decodeErrorData: sse_decode_portal_error,
      ),
      constMeta: kStartUploadConstMeta,
      argValues: [deviceId, tokens, files],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kStartUploadConstMeta => const TaskConstMeta(
        debugName: "start_upload",
        argNames: ["deviceId", "tokens", "files"],
      );

  @override
  Future<UpgradeProgress> upgradeStation(
      {required String deviceId,
      required LocalFirmware firmware,
      required bool swap,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        sse_encode_box_autoadd_local_firmware(firmware, serializer);
        sse_encode_bool(swap, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_upgrade_progress,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kUpgradeStationConstMeta,
      argValues: [deviceId, firmware, swap],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kUpgradeStationConstMeta => const TaskConstMeta(
        debugName: "upgrade_station",
        argNames: ["deviceId", "firmware", "swap"],
      );

  @override
  Future<Authenticated> validateTokens({required Tokens tokens, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_tokens(tokens, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_authenticated,
        decodeErrorData: sse_decode_portal_error,
      ),
      constMeta: kValidateTokensConstMeta,
      argValues: [tokens],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kValidateTokensConstMeta => const TaskConstMeta(
        debugName: "validate_tokens",
        argNames: ["tokens"],
      );

  @override
  Future<void> verifyLoraTransmission(
      {required String deviceId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kVerifyLoraTransmissionConstMeta,
      argValues: [deviceId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kVerifyLoraTransmissionConstMeta => const TaskConstMeta(
        debugName: "verify_lora_transmission",
        argNames: ["deviceId"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AddOrUpdatePortalStation dco_decode_add_or_update_portal_station(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return AddOrUpdatePortalStation(
      name: dco_decode_String(arr[0]),
      deviceId: dco_decode_String(arr[1]),
      locationName: dco_decode_String(arr[2]),
      statusPb: dco_decode_String(arr[3]),
    );
  }

  @protected
  Authenticated dco_decode_authenticated(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Authenticated(
      email: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      tokens: dco_decode_tokens(arr[2]),
    );
  }

  @protected
  BatteryInfo dco_decode_battery_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BatteryInfo(
      percentage: dco_decode_f_32(arr[0]),
      voltage: dco_decode_f_32(arr[1]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AddOrUpdatePortalStation dco_decode_box_autoadd_add_or_update_portal_station(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_add_or_update_portal_station(raw);
  }

  @protected
  DeployConfig dco_decode_box_autoadd_deploy_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_deploy_config(raw);
  }

  @protected
  DeploymentConfig dco_decode_box_autoadd_deployment_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_deployment_config(raw);
  }

  @protected
  DownloadProgress dco_decode_box_autoadd_download_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_download_progress(raw);
  }

  @protected
  EphemeralConfig dco_decode_box_autoadd_ephemeral_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ephemeral_config(raw);
  }

  @protected
  FirmwareDownloadStatus dco_decode_box_autoadd_firmware_download_status(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_firmware_download_status(raw);
  }

  @protected
  int dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  LocalFirmware dco_decode_box_autoadd_local_firmware(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_local_firmware(raw);
  }

  @protected
  LoraConfig dco_decode_box_autoadd_lora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lora_config(raw);
  }

  @protected
  LoraTransmissionConfig dco_decode_box_autoadd_lora_transmission_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lora_transmission_config(raw);
  }

  @protected
  NameConfig dco_decode_box_autoadd_name_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_name_config(raw);
  }

  @protected
  Schedule dco_decode_box_autoadd_schedule(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_schedule(raw);
  }

  @protected
  SensorValue dco_decode_box_autoadd_sensor_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sensor_value(raw);
  }

  @protected
  StationConfig dco_decode_box_autoadd_station_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_station_config(raw);
  }

  @protected
  Tokens dco_decode_box_autoadd_tokens(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_tokens(raw);
  }

  @protected
  TransferProgress dco_decode_box_autoadd_transfer_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_transfer_progress(raw);
  }

  @protected
  TransmissionConfig dco_decode_box_autoadd_transmission_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_transmission_config(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  UpgradeProgress dco_decode_box_autoadd_upgrade_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_upgrade_progress(raw);
  }

  @protected
  UploadProgress dco_decode_box_autoadd_upload_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_upload_progress(raw);
  }

  @protected
  WifiNetworksConfig dco_decode_box_autoadd_wifi_networks_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wifi_networks_config(raw);
  }

  @protected
  WifiTransmissionConfig dco_decode_box_autoadd_wifi_transmission_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wifi_transmission_config(raw);
  }

  @protected
  DeployConfig dco_decode_deploy_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return DeployConfig(
      location: dco_decode_String(arr[0]),
      deployed: dco_decode_u_64(arr[1]),
      schedule: dco_decode_schedule(arr[2]),
    );
  }

  @protected
  DeploymentConfig dco_decode_deployment_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return DeploymentConfig(
      startTime: dco_decode_u_64(arr[0]),
    );
  }

  @protected
  DeviceCapabilities dco_decode_device_capabilities(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return DeviceCapabilities(
      udp: dco_decode_bool(arr[0]),
    );
  }

  @protected
  DomainMessage dco_decode_domain_message(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DomainMessage_PreAccount();
      case 1:
        return DomainMessage_NearbyStations(
          dco_decode_list_nearby_station(raw[1]),
        );
      case 2:
        return DomainMessage_StationRefreshed(
          dco_decode_box_autoadd_station_config(raw[1]),
          dco_decode_opt_box_autoadd_ephemeral_config(raw[2]),
          dco_decode_String(raw[3]),
        );
      case 3:
        return DomainMessage_UploadProgress(
          dco_decode_box_autoadd_transfer_progress(raw[1]),
        );
      case 4:
        return DomainMessage_DownloadProgress(
          dco_decode_box_autoadd_transfer_progress(raw[1]),
        );
      case 5:
        return DomainMessage_FirmwareDownloadStatus(
          dco_decode_box_autoadd_firmware_download_status(raw[1]),
        );
      case 6:
        return DomainMessage_UpgradeProgress(
          dco_decode_box_autoadd_upgrade_progress(raw[1]),
        );
      case 7:
        return DomainMessage_AvailableFirmware(
          dco_decode_list_local_firmware(raw[1]),
        );
      case 8:
        return DomainMessage_RecordArchives(
          dco_decode_list_record_archive(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  DownloadProgress dco_decode_download_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return DownloadProgress(
      started: dco_decode_u_64(arr[0]),
      completed: dco_decode_f_32(arr[1]),
      total: dco_decode_usize(arr[2]),
      received: dco_decode_usize(arr[3]),
    );
  }

  @protected
  EphemeralConfig dco_decode_ephemeral_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return EphemeralConfig(
      queried: dco_decode_utc_date_time(arr[0]),
      deployment: dco_decode_opt_box_autoadd_deployment_config(arr[1]),
      transmission: dco_decode_opt_box_autoadd_transmission_config(arr[2]),
      networks: dco_decode_list_network_config(arr[3]),
      lora: dco_decode_opt_box_autoadd_lora_config(arr[4]),
      capabilities: dco_decode_device_capabilities(arr[5]),
      events: dco_decode_list_prim_u_8_strict(arr[6]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FirmwareDownloadStatus dco_decode_firmware_download_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return FirmwareDownloadStatus_Checking();
      case 1:
        return FirmwareDownloadStatus_Downloading(
          dco_decode_box_autoadd_download_progress(raw[1]),
        );
      case 2:
        return FirmwareDownloadStatus_Offline();
      case 3:
        return FirmwareDownloadStatus_Completed();
      case 4:
        return FirmwareDownloadStatus_Failed();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  FirmwareInfo dco_decode_firmware_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FirmwareInfo(
      label: dco_decode_String(arr[0]),
      time: dco_decode_i_64(arr[1]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  List<LocalFirmware> dco_decode_list_local_firmware(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_local_firmware).toList();
  }

  @protected
  List<ModuleConfig> dco_decode_list_module_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_module_config).toList();
  }

  @protected
  List<NearbyStation> dco_decode_list_nearby_station(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_nearby_station).toList();
  }

  @protected
  List<NetworkConfig> dco_decode_list_network_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_network_config).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<RecordArchive> dco_decode_list_record_archive(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_archive).toList();
  }

  @protected
  List<SensorConfig> dco_decode_list_sensor_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_sensor_config).toList();
  }

  @protected
  List<StationConfig> dco_decode_list_station_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_station_config).toList();
  }

  @protected
  List<WifiNetworkConfig> dco_decode_list_wifi_network_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wifi_network_config).toList();
  }

  @protected
  LocalFirmware dco_decode_local_firmware(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return LocalFirmware(
      id: dco_decode_i_64(arr[0]),
      label: dco_decode_String(arr[1]),
      time: dco_decode_i_64(arr[2]),
      module: dco_decode_String(arr[3]),
      profile: dco_decode_String(arr[4]),
    );
  }

  @protected
  LoraBand dco_decode_lora_band(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LoraBand.values[raw as int];
  }

  @protected
  LoraConfig dco_decode_lora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return LoraConfig(
      available: dco_decode_bool(arr[0]),
      band: dco_decode_lora_band(arr[1]),
      deviceEui: dco_decode_list_prim_u_8_strict(arr[2]),
      appKey: dco_decode_list_prim_u_8_strict(arr[3]),
      joinEui: dco_decode_list_prim_u_8_strict(arr[4]),
      deviceAddress: dco_decode_list_prim_u_8_strict(arr[5]),
      networkSessionKey: dco_decode_list_prim_u_8_strict(arr[6]),
      appSessionKey: dco_decode_list_prim_u_8_strict(arr[7]),
    );
  }

  @protected
  LoraTransmissionConfig dco_decode_lora_transmission_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LoraTransmissionConfig(
      band: dco_decode_opt_box_autoadd_u_32(arr[0]),
      appKey: dco_decode_opt_list_prim_u_8_strict(arr[1]),
      joinEui: dco_decode_opt_list_prim_u_8_strict(arr[2]),
      schedule: dco_decode_opt_box_autoadd_schedule(arr[3]),
    );
  }

  @protected
  ModuleConfig dco_decode_module_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ModuleConfig(
      position: dco_decode_u_32(arr[0]),
      moduleId: dco_decode_String(arr[1]),
      key: dco_decode_String(arr[2]),
      sensors: dco_decode_list_sensor_config(arr[3]),
      configuration: dco_decode_opt_list_prim_u_8_strict(arr[4]),
    );
  }

  @protected
  NameConfig dco_decode_name_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return NameConfig(
      name: dco_decode_String(arr[0]),
    );
  }

  @protected
  NearbyStation dco_decode_nearby_station(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return NearbyStation(
      deviceId: dco_decode_String(arr[0]),
      busy: dco_decode_bool(arr[1]),
    );
  }

  @protected
  NetworkConfig dco_decode_network_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return NetworkConfig(
      index: dco_decode_usize(arr[0]),
      ssid: dco_decode_String(arr[1]),
      preferred: dco_decode_bool(arr[2]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  DeploymentConfig? dco_decode_opt_box_autoadd_deployment_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_deployment_config(raw);
  }

  @protected
  EphemeralConfig? dco_decode_opt_box_autoadd_ephemeral_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ephemeral_config(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  LoraConfig? dco_decode_opt_box_autoadd_lora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_lora_config(raw);
  }

  @protected
  Schedule? dco_decode_opt_box_autoadd_schedule(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_schedule(raw);
  }

  @protected
  SensorValue? dco_decode_opt_box_autoadd_sensor_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_sensor_value(raw);
  }

  @protected
  Tokens? dco_decode_opt_box_autoadd_tokens(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_tokens(raw);
  }

  @protected
  TransmissionConfig? dco_decode_opt_box_autoadd_transmission_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_transmission_config(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  PortalError dco_decode_portal_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PortalError_Authentication();
      case 1:
        return PortalError_Connecting();
      case 2:
        return PortalError_Other(
          dco_decode_String(raw[1]),
        );
      case 3:
        return PortalError_Sdk();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RecordArchive dco_decode_record_archive(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return RecordArchive(
      deviceId: dco_decode_String(arr[0]),
      generationId: dco_decode_String(arr[1]),
      path: dco_decode_String(arr[2]),
      head: dco_decode_i_64(arr[3]),
      tail: dco_decode_i_64(arr[4]),
      uploaded: dco_decode_opt_box_autoadd_i_64(arr[5]),
    );
  }

  @protected
  Registered dco_decode_registered(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Registered(
      email: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
    );
  }

  @protected
  Schedule dco_decode_schedule(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Schedule_Every(
          dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SensorConfig dco_decode_sensor_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return SensorConfig(
      number: dco_decode_u_32(arr[0]),
      key: dco_decode_String(arr[1]),
      fullKey: dco_decode_String(arr[2]),
      calibratedUom: dco_decode_String(arr[3]),
      uncalibratedUom: dco_decode_String(arr[4]),
      value: dco_decode_opt_box_autoadd_sensor_value(arr[5]),
      previousValue: dco_decode_opt_box_autoadd_sensor_value(arr[6]),
    );
  }

  @protected
  SensorValue dco_decode_sensor_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SensorValue(
      time: dco_decode_utc_date_time(arr[0]),
      value: dco_decode_f_32(arr[1]),
      uncalibrated: dco_decode_f_32(arr[2]),
    );
  }

  @protected
  SolarInfo dco_decode_solar_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SolarInfo(
      voltage: dco_decode_f_32(arr[0]),
    );
  }

  @protected
  StationConfig dco_decode_station_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return StationConfig(
      deviceId: dco_decode_String(arr[0]),
      generationId: dco_decode_String(arr[1]),
      name: dco_decode_String(arr[2]),
      firmware: dco_decode_firmware_info(arr[3]),
      lastSeen: dco_decode_utc_date_time(arr[4]),
      meta: dco_decode_stream_info(arr[5]),
      data: dco_decode_stream_info(arr[6]),
      battery: dco_decode_battery_info(arr[7]),
      solar: dco_decode_solar_info(arr[8]),
      pb: dco_decode_opt_list_prim_u_8_strict(arr[9]),
      modules: dco_decode_list_module_config(arr[10]),
    );
  }

  @protected
  StreamInfo dco_decode_stream_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return StreamInfo(
      size: dco_decode_u_64(arr[0]),
      records: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  Tokens dco_decode_tokens(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Tokens(
      token: dco_decode_String(arr[0]),
      transmission: dco_decode_transmission_token(arr[1]),
    );
  }

  @protected
  TransferProgress dco_decode_transfer_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TransferProgress(
      deviceId: dco_decode_String(arr[0]),
      status: dco_decode_transfer_status(arr[1]),
    );
  }

  @protected
  TransferStatus dco_decode_transfer_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return TransferStatus_Starting();
      case 1:
        return TransferStatus_Downloading(
          dco_decode_box_autoadd_download_progress(raw[1]),
        );
      case 2:
        return TransferStatus_Uploading(
          dco_decode_box_autoadd_upload_progress(raw[1]),
        );
      case 3:
        return TransferStatus_Processing();
      case 4:
        return TransferStatus_Completed();
      case 5:
        return TransferStatus_Failed();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  TransmissionConfig dco_decode_transmission_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return TransmissionConfig(
      enabled: dco_decode_bool(arr[0]),
    );
  }

  @protected
  TransmissionToken dco_decode_transmission_token(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TransmissionToken(
      token: dco_decode_String(arr[0]),
      url: dco_decode_String(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UpgradeProgress dco_decode_upgrade_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return UpgradeProgress(
      deviceId: dco_decode_String(arr[0]),
      firmwareId: dco_decode_i_64(arr[1]),
      status: dco_decode_upgrade_status(arr[2]),
    );
  }

  @protected
  UpgradeStatus dco_decode_upgrade_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return UpgradeStatus_Starting();
      case 1:
        return UpgradeStatus_Uploading(
          dco_decode_box_autoadd_upload_progress(raw[1]),
        );
      case 2:
        return UpgradeStatus_Restarting();
      case 3:
        return UpgradeStatus_ReconnectTimeout();
      case 4:
        return UpgradeStatus_Completed();
      case 5:
        return UpgradeStatus_Failed();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  UploadProgress dco_decode_upload_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return UploadProgress(
      bytesUploaded: dco_decode_u_64(arr[0]),
      totalBytes: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  int dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  UtcDateTime dco_decode_utc_date_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return UtcDateTime(
      field0: dco_decode_i_64(arr[0]),
    );
  }

  @protected
  WifiNetworkConfig dco_decode_wifi_network_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return WifiNetworkConfig(
      index: dco_decode_usize(arr[0]),
      ssid: dco_decode_opt_String(arr[1]),
      password: dco_decode_opt_String(arr[2]),
      preferred: dco_decode_bool(arr[3]),
      keeping: dco_decode_bool(arr[4]),
    );
  }

  @protected
  WifiNetworksConfig dco_decode_wifi_networks_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return WifiNetworksConfig(
      networks: dco_decode_list_wifi_network_config(arr[0]),
    );
  }

  @protected
  WifiTransmissionConfig dco_decode_wifi_transmission_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return WifiTransmissionConfig(
      tokens: dco_decode_opt_box_autoadd_tokens(arr[0]),
      schedule: dco_decode_opt_box_autoadd_schedule(arr[1]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AddOrUpdatePortalStation sse_decode_add_or_update_portal_station(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_deviceId = sse_decode_String(deserializer);
    var var_locationName = sse_decode_String(deserializer);
    var var_statusPb = sse_decode_String(deserializer);
    return AddOrUpdatePortalStation(
        name: var_name,
        deviceId: var_deviceId,
        locationName: var_locationName,
        statusPb: var_statusPb);
  }

  @protected
  Authenticated sse_decode_authenticated(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_email = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_tokens = sse_decode_tokens(deserializer);
    return Authenticated(email: var_email, name: var_name, tokens: var_tokens);
  }

  @protected
  BatteryInfo sse_decode_battery_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_percentage = sse_decode_f_32(deserializer);
    var var_voltage = sse_decode_f_32(deserializer);
    return BatteryInfo(percentage: var_percentage, voltage: var_voltage);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AddOrUpdatePortalStation sse_decode_box_autoadd_add_or_update_portal_station(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_add_or_update_portal_station(deserializer));
  }

  @protected
  DeployConfig sse_decode_box_autoadd_deploy_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_deploy_config(deserializer));
  }

  @protected
  DeploymentConfig sse_decode_box_autoadd_deployment_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_deployment_config(deserializer));
  }

  @protected
  DownloadProgress sse_decode_box_autoadd_download_progress(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_download_progress(deserializer));
  }

  @protected
  EphemeralConfig sse_decode_box_autoadd_ephemeral_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ephemeral_config(deserializer));
  }

  @protected
  FirmwareDownloadStatus sse_decode_box_autoadd_firmware_download_status(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_firmware_download_status(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_64(deserializer));
  }

  @protected
  LocalFirmware sse_decode_box_autoadd_local_firmware(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_local_firmware(deserializer));
  }

  @protected
  LoraConfig sse_decode_box_autoadd_lora_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lora_config(deserializer));
  }

  @protected
  LoraTransmissionConfig sse_decode_box_autoadd_lora_transmission_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lora_transmission_config(deserializer));
  }

  @protected
  NameConfig sse_decode_box_autoadd_name_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_name_config(deserializer));
  }

  @protected
  Schedule sse_decode_box_autoadd_schedule(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_schedule(deserializer));
  }

  @protected
  SensorValue sse_decode_box_autoadd_sensor_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sensor_value(deserializer));
  }

  @protected
  StationConfig sse_decode_box_autoadd_station_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_station_config(deserializer));
  }

  @protected
  Tokens sse_decode_box_autoadd_tokens(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_tokens(deserializer));
  }

  @protected
  TransferProgress sse_decode_box_autoadd_transfer_progress(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_transfer_progress(deserializer));
  }

  @protected
  TransmissionConfig sse_decode_box_autoadd_transmission_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_transmission_config(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  UpgradeProgress sse_decode_box_autoadd_upgrade_progress(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_upgrade_progress(deserializer));
  }

  @protected
  UploadProgress sse_decode_box_autoadd_upload_progress(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_upload_progress(deserializer));
  }

  @protected
  WifiNetworksConfig sse_decode_box_autoadd_wifi_networks_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_wifi_networks_config(deserializer));
  }

  @protected
  WifiTransmissionConfig sse_decode_box_autoadd_wifi_transmission_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_wifi_transmission_config(deserializer));
  }

  @protected
  DeployConfig sse_decode_deploy_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_location = sse_decode_String(deserializer);
    var var_deployed = sse_decode_u_64(deserializer);
    var var_schedule = sse_decode_schedule(deserializer);
    return DeployConfig(
        location: var_location, deployed: var_deployed, schedule: var_schedule);
  }

  @protected
  DeploymentConfig sse_decode_deployment_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_startTime = sse_decode_u_64(deserializer);
    return DeploymentConfig(startTime: var_startTime);
  }

  @protected
  DeviceCapabilities sse_decode_device_capabilities(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_udp = sse_decode_bool(deserializer);
    return DeviceCapabilities(udp: var_udp);
  }

  @protected
  DomainMessage sse_decode_domain_message(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DomainMessage_PreAccount();
      case 1:
        var var_field0 = sse_decode_list_nearby_station(deserializer);
        return DomainMessage_NearbyStations(var_field0);
      case 2:
        var var_field0 = sse_decode_box_autoadd_station_config(deserializer);
        var var_field1 =
            sse_decode_opt_box_autoadd_ephemeral_config(deserializer);
        var var_field2 = sse_decode_String(deserializer);
        return DomainMessage_StationRefreshed(
            var_field0, var_field1, var_field2);
      case 3:
        var var_field0 = sse_decode_box_autoadd_transfer_progress(deserializer);
        return DomainMessage_UploadProgress(var_field0);
      case 4:
        var var_field0 = sse_decode_box_autoadd_transfer_progress(deserializer);
        return DomainMessage_DownloadProgress(var_field0);
      case 5:
        var var_field0 =
            sse_decode_box_autoadd_firmware_download_status(deserializer);
        return DomainMessage_FirmwareDownloadStatus(var_field0);
      case 6:
        var var_field0 = sse_decode_box_autoadd_upgrade_progress(deserializer);
        return DomainMessage_UpgradeProgress(var_field0);
      case 7:
        var var_field0 = sse_decode_list_local_firmware(deserializer);
        return DomainMessage_AvailableFirmware(var_field0);
      case 8:
        var var_field0 = sse_decode_list_record_archive(deserializer);
        return DomainMessage_RecordArchives(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  DownloadProgress sse_decode_download_progress(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_started = sse_decode_u_64(deserializer);
    var var_completed = sse_decode_f_32(deserializer);
    var var_total = sse_decode_usize(deserializer);
    var var_received = sse_decode_usize(deserializer);
    return DownloadProgress(
        started: var_started,
        completed: var_completed,
        total: var_total,
        received: var_received);
  }

  @protected
  EphemeralConfig sse_decode_ephemeral_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_queried = sse_decode_utc_date_time(deserializer);
    var var_deployment =
        sse_decode_opt_box_autoadd_deployment_config(deserializer);
    var var_transmission =
        sse_decode_opt_box_autoadd_transmission_config(deserializer);
    var var_networks = sse_decode_list_network_config(deserializer);
    var var_lora = sse_decode_opt_box_autoadd_lora_config(deserializer);
    var var_capabilities = sse_decode_device_capabilities(deserializer);
    var var_events = sse_decode_list_prim_u_8_strict(deserializer);
    return EphemeralConfig(
        queried: var_queried,
        deployment: var_deployment,
        transmission: var_transmission,
        networks: var_networks,
        lora: var_lora,
        capabilities: var_capabilities,
        events: var_events);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  FirmwareDownloadStatus sse_decode_firmware_download_status(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return FirmwareDownloadStatus_Checking();
      case 1:
        var var_field0 = sse_decode_box_autoadd_download_progress(deserializer);
        return FirmwareDownloadStatus_Downloading(var_field0);
      case 2:
        return FirmwareDownloadStatus_Offline();
      case 3:
        return FirmwareDownloadStatus_Completed();
      case 4:
        return FirmwareDownloadStatus_Failed();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  FirmwareInfo sse_decode_firmware_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_label = sse_decode_String(deserializer);
    var var_time = sse_decode_i_64(deserializer);
    return FirmwareInfo(label: var_label, time: var_time);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  int sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt64();
  }

  @protected
  List<LocalFirmware> sse_decode_list_local_firmware(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalFirmware>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_local_firmware(deserializer));
    }
    return ans_;
  }

  @protected
  List<ModuleConfig> sse_decode_list_module_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ModuleConfig>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_module_config(deserializer));
    }
    return ans_;
  }

  @protected
  List<NearbyStation> sse_decode_list_nearby_station(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NearbyStation>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_nearby_station(deserializer));
    }
    return ans_;
  }

  @protected
  List<NetworkConfig> sse_decode_list_network_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NetworkConfig>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_network_config(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<RecordArchive> sse_decode_list_record_archive(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RecordArchive>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_archive(deserializer));
    }
    return ans_;
  }

  @protected
  List<SensorConfig> sse_decode_list_sensor_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SensorConfig>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_sensor_config(deserializer));
    }
    return ans_;
  }

  @protected
  List<StationConfig> sse_decode_list_station_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <StationConfig>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_station_config(deserializer));
    }
    return ans_;
  }

  @protected
  List<WifiNetworkConfig> sse_decode_list_wifi_network_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WifiNetworkConfig>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wifi_network_config(deserializer));
    }
    return ans_;
  }

  @protected
  LocalFirmware sse_decode_local_firmware(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_label = sse_decode_String(deserializer);
    var var_time = sse_decode_i_64(deserializer);
    var var_module = sse_decode_String(deserializer);
    var var_profile = sse_decode_String(deserializer);
    return LocalFirmware(
        id: var_id,
        label: var_label,
        time: var_time,
        module: var_module,
        profile: var_profile);
  }

  @protected
  LoraBand sse_decode_lora_band(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return LoraBand.values[inner];
  }

  @protected
  LoraConfig sse_decode_lora_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_available = sse_decode_bool(deserializer);
    var var_band = sse_decode_lora_band(deserializer);
    var var_deviceEui = sse_decode_list_prim_u_8_strict(deserializer);
    var var_appKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_joinEui = sse_decode_list_prim_u_8_strict(deserializer);
    var var_deviceAddress = sse_decode_list_prim_u_8_strict(deserializer);
    var var_networkSessionKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_appSessionKey = sse_decode_list_prim_u_8_strict(deserializer);
    return LoraConfig(
        available: var_available,
        band: var_band,
        deviceEui: var_deviceEui,
        appKey: var_appKey,
        joinEui: var_joinEui,
        deviceAddress: var_deviceAddress,
        networkSessionKey: var_networkSessionKey,
        appSessionKey: var_appSessionKey);
  }

  @protected
  LoraTransmissionConfig sse_decode_lora_transmission_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_band = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_appKey = sse_decode_opt_list_prim_u_8_strict(deserializer);
    var var_joinEui = sse_decode_opt_list_prim_u_8_strict(deserializer);
    var var_schedule = sse_decode_opt_box_autoadd_schedule(deserializer);
    return LoraTransmissionConfig(
        band: var_band,
        appKey: var_appKey,
        joinEui: var_joinEui,
        schedule: var_schedule);
  }

  @protected
  ModuleConfig sse_decode_module_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_position = sse_decode_u_32(deserializer);
    var var_moduleId = sse_decode_String(deserializer);
    var var_key = sse_decode_String(deserializer);
    var var_sensors = sse_decode_list_sensor_config(deserializer);
    var var_configuration = sse_decode_opt_list_prim_u_8_strict(deserializer);
    return ModuleConfig(
        position: var_position,
        moduleId: var_moduleId,
        key: var_key,
        sensors: var_sensors,
        configuration: var_configuration);
  }

  @protected
  NameConfig sse_decode_name_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    return NameConfig(name: var_name);
  }

  @protected
  NearbyStation sse_decode_nearby_station(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_String(deserializer);
    var var_busy = sse_decode_bool(deserializer);
    return NearbyStation(deviceId: var_deviceId, busy: var_busy);
  }

  @protected
  NetworkConfig sse_decode_network_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_usize(deserializer);
    var var_ssid = sse_decode_String(deserializer);
    var var_preferred = sse_decode_bool(deserializer);
    return NetworkConfig(
        index: var_index, ssid: var_ssid, preferred: var_preferred);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  DeploymentConfig? sse_decode_opt_box_autoadd_deployment_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_deployment_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  EphemeralConfig? sse_decode_opt_box_autoadd_ephemeral_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ephemeral_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LoraConfig? sse_decode_opt_box_autoadd_lora_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_lora_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Schedule? sse_decode_opt_box_autoadd_schedule(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_schedule(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SensorValue? sse_decode_opt_box_autoadd_sensor_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_sensor_value(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Tokens? sse_decode_opt_box_autoadd_tokens(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_tokens(deserializer));
    } else {
      return null;
    }
  }

  @protected
  TransmissionConfig? sse_decode_opt_box_autoadd_transmission_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_transmission_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PortalError sse_decode_portal_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return PortalError_Authentication();
      case 1:
        return PortalError_Connecting();
      case 2:
        var var_field0 = sse_decode_String(deserializer);
        return PortalError_Other(var_field0);
      case 3:
        return PortalError_Sdk();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RecordArchive sse_decode_record_archive(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_String(deserializer);
    var var_generationId = sse_decode_String(deserializer);
    var var_path = sse_decode_String(deserializer);
    var var_head = sse_decode_i_64(deserializer);
    var var_tail = sse_decode_i_64(deserializer);
    var var_uploaded = sse_decode_opt_box_autoadd_i_64(deserializer);
    return RecordArchive(
        deviceId: var_deviceId,
        generationId: var_generationId,
        path: var_path,
        head: var_head,
        tail: var_tail,
        uploaded: var_uploaded);
  }

  @protected
  Registered sse_decode_registered(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_email = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    return Registered(email: var_email, name: var_name);
  }

  @protected
  Schedule sse_decode_schedule(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_u_32(deserializer);
        return Schedule_Every(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SensorConfig sse_decode_sensor_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_number = sse_decode_u_32(deserializer);
    var var_key = sse_decode_String(deserializer);
    var var_fullKey = sse_decode_String(deserializer);
    var var_calibratedUom = sse_decode_String(deserializer);
    var var_uncalibratedUom = sse_decode_String(deserializer);
    var var_value = sse_decode_opt_box_autoadd_sensor_value(deserializer);
    var var_previousValue =
        sse_decode_opt_box_autoadd_sensor_value(deserializer);
    return SensorConfig(
        number: var_number,
        key: var_key,
        fullKey: var_fullKey,
        calibratedUom: var_calibratedUom,
        uncalibratedUom: var_uncalibratedUom,
        value: var_value,
        previousValue: var_previousValue);
  }

  @protected
  SensorValue sse_decode_sensor_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_time = sse_decode_utc_date_time(deserializer);
    var var_value = sse_decode_f_32(deserializer);
    var var_uncalibrated = sse_decode_f_32(deserializer);
    return SensorValue(
        time: var_time, value: var_value, uncalibrated: var_uncalibrated);
  }

  @protected
  SolarInfo sse_decode_solar_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_voltage = sse_decode_f_32(deserializer);
    return SolarInfo(voltage: var_voltage);
  }

  @protected
  StationConfig sse_decode_station_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_String(deserializer);
    var var_generationId = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_firmware = sse_decode_firmware_info(deserializer);
    var var_lastSeen = sse_decode_utc_date_time(deserializer);
    var var_meta = sse_decode_stream_info(deserializer);
    var var_data = sse_decode_stream_info(deserializer);
    var var_battery = sse_decode_battery_info(deserializer);
    var var_solar = sse_decode_solar_info(deserializer);
    var var_pb = sse_decode_opt_list_prim_u_8_strict(deserializer);
    var var_modules = sse_decode_list_module_config(deserializer);
    return StationConfig(
        deviceId: var_deviceId,
        generationId: var_generationId,
        name: var_name,
        firmware: var_firmware,
        lastSeen: var_lastSeen,
        meta: var_meta,
        data: var_data,
        battery: var_battery,
        solar: var_solar,
        pb: var_pb,
        modules: var_modules);
  }

  @protected
  StreamInfo sse_decode_stream_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_size = sse_decode_u_64(deserializer);
    var var_records = sse_decode_u_64(deserializer);
    return StreamInfo(size: var_size, records: var_records);
  }

  @protected
  Tokens sse_decode_tokens(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_token = sse_decode_String(deserializer);
    var var_transmission = sse_decode_transmission_token(deserializer);
    return Tokens(token: var_token, transmission: var_transmission);
  }

  @protected
  TransferProgress sse_decode_transfer_progress(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_String(deserializer);
    var var_status = sse_decode_transfer_status(deserializer);
    return TransferProgress(deviceId: var_deviceId, status: var_status);
  }

  @protected
  TransferStatus sse_decode_transfer_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return TransferStatus_Starting();
      case 1:
        var var_field0 = sse_decode_box_autoadd_download_progress(deserializer);
        return TransferStatus_Downloading(var_field0);
      case 2:
        var var_field0 = sse_decode_box_autoadd_upload_progress(deserializer);
        return TransferStatus_Uploading(var_field0);
      case 3:
        return TransferStatus_Processing();
      case 4:
        return TransferStatus_Completed();
      case 5:
        return TransferStatus_Failed();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  TransmissionConfig sse_decode_transmission_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_enabled = sse_decode_bool(deserializer);
    return TransmissionConfig(enabled: var_enabled);
  }

  @protected
  TransmissionToken sse_decode_transmission_token(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_token = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    return TransmissionToken(token: var_token, url: var_url);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UpgradeProgress sse_decode_upgrade_progress(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_String(deserializer);
    var var_firmwareId = sse_decode_i_64(deserializer);
    var var_status = sse_decode_upgrade_status(deserializer);
    return UpgradeProgress(
        deviceId: var_deviceId, firmwareId: var_firmwareId, status: var_status);
  }

  @protected
  UpgradeStatus sse_decode_upgrade_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return UpgradeStatus_Starting();
      case 1:
        var var_field0 = sse_decode_box_autoadd_upload_progress(deserializer);
        return UpgradeStatus_Uploading(var_field0);
      case 2:
        return UpgradeStatus_Restarting();
      case 3:
        return UpgradeStatus_ReconnectTimeout();
      case 4:
        return UpgradeStatus_Completed();
      case 5:
        return UpgradeStatus_Failed();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  UploadProgress sse_decode_upload_progress(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bytesUploaded = sse_decode_u_64(deserializer);
    var var_totalBytes = sse_decode_u_64(deserializer);
    return UploadProgress(
        bytesUploaded: var_bytesUploaded, totalBytes: var_totalBytes);
  }

  @protected
  int sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  UtcDateTime sse_decode_utc_date_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_i_64(deserializer);
    return UtcDateTime(field0: var_field0);
  }

  @protected
  WifiNetworkConfig sse_decode_wifi_network_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_usize(deserializer);
    var var_ssid = sse_decode_opt_String(deserializer);
    var var_password = sse_decode_opt_String(deserializer);
    var var_preferred = sse_decode_bool(deserializer);
    var var_keeping = sse_decode_bool(deserializer);
    return WifiNetworkConfig(
        index: var_index,
        ssid: var_ssid,
        password: var_password,
        preferred: var_preferred,
        keeping: var_keeping);
  }

  @protected
  WifiNetworksConfig sse_decode_wifi_networks_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_networks = sse_decode_list_wifi_network_config(deserializer);
    return WifiNetworksConfig(networks: var_networks);
  }

  @protected
  WifiTransmissionConfig sse_decode_wifi_transmission_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tokens = sse_decode_opt_box_autoadd_tokens(deserializer);
    var var_schedule = sse_decode_opt_box_autoadd_schedule(deserializer);
    return WifiTransmissionConfig(tokens: var_tokens, schedule: var_schedule);
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ((');
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_add_or_update_portal_station(
      AddOrUpdatePortalStation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.deviceId, serializer);
    sse_encode_String(self.locationName, serializer);
    sse_encode_String(self.statusPb, serializer);
  }

  @protected
  void sse_encode_authenticated(Authenticated self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.email, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_tokens(self.tokens, serializer);
  }

  @protected
  void sse_encode_battery_info(BatteryInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.percentage, serializer);
    sse_encode_f_32(self.voltage, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_add_or_update_portal_station(
      AddOrUpdatePortalStation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_add_or_update_portal_station(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_deploy_config(
      DeployConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_deploy_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_deployment_config(
      DeploymentConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_deployment_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_download_progress(
      DownloadProgress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_download_progress(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ephemeral_config(
      EphemeralConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ephemeral_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_firmware_download_status(
      FirmwareDownloadStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_firmware_download_status(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_local_firmware(
      LocalFirmware self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_local_firmware(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lora_config(
      LoraConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lora_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lora_transmission_config(
      LoraTransmissionConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lora_transmission_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_name_config(
      NameConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_name_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_schedule(
      Schedule self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_schedule(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sensor_value(
      SensorValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sensor_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_station_config(
      StationConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_station_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_tokens(Tokens self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_tokens(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_transfer_progress(
      TransferProgress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_transfer_progress(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_transmission_config(
      TransmissionConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_transmission_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_upgrade_progress(
      UpgradeProgress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_upgrade_progress(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_upload_progress(
      UploadProgress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_upload_progress(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_wifi_networks_config(
      WifiNetworksConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wifi_networks_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_wifi_transmission_config(
      WifiTransmissionConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wifi_transmission_config(self, serializer);
  }

  @protected
  void sse_encode_deploy_config(DeployConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.location, serializer);
    sse_encode_u_64(self.deployed, serializer);
    sse_encode_schedule(self.schedule, serializer);
  }

  @protected
  void sse_encode_deployment_config(
      DeploymentConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.startTime, serializer);
  }

  @protected
  void sse_encode_device_capabilities(
      DeviceCapabilities self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.udp, serializer);
  }

  @protected
  void sse_encode_domain_message(DomainMessage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DomainMessage_PreAccount():
        sse_encode_i_32(0, serializer);
      case DomainMessage_NearbyStations(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_list_nearby_station(field0, serializer);
      case DomainMessage_StationRefreshed(
          field0: final field0,
          field1: final field1,
          field2: final field2
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_station_config(field0, serializer);
        sse_encode_opt_box_autoadd_ephemeral_config(field1, serializer);
        sse_encode_String(field2, serializer);
      case DomainMessage_UploadProgress(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_transfer_progress(field0, serializer);
      case DomainMessage_DownloadProgress(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_transfer_progress(field0, serializer);
      case DomainMessage_FirmwareDownloadStatus(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_firmware_download_status(field0, serializer);
      case DomainMessage_UpgradeProgress(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_box_autoadd_upgrade_progress(field0, serializer);
      case DomainMessage_AvailableFirmware(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_list_local_firmware(field0, serializer);
      case DomainMessage_RecordArchives(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_list_record_archive(field0, serializer);
    }
  }

  @protected
  void sse_encode_download_progress(
      DownloadProgress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.started, serializer);
    sse_encode_f_32(self.completed, serializer);
    sse_encode_usize(self.total, serializer);
    sse_encode_usize(self.received, serializer);
  }

  @protected
  void sse_encode_ephemeral_config(
      EphemeralConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_utc_date_time(self.queried, serializer);
    sse_encode_opt_box_autoadd_deployment_config(self.deployment, serializer);
    sse_encode_opt_box_autoadd_transmission_config(
        self.transmission, serializer);
    sse_encode_list_network_config(self.networks, serializer);
    sse_encode_opt_box_autoadd_lora_config(self.lora, serializer);
    sse_encode_device_capabilities(self.capabilities, serializer);
    sse_encode_list_prim_u_8_strict(self.events, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_firmware_download_status(
      FirmwareDownloadStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case FirmwareDownloadStatus_Checking():
        sse_encode_i_32(0, serializer);
      case FirmwareDownloadStatus_Downloading(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_download_progress(field0, serializer);
      case FirmwareDownloadStatus_Offline():
        sse_encode_i_32(2, serializer);
      case FirmwareDownloadStatus_Completed():
        sse_encode_i_32(3, serializer);
      case FirmwareDownloadStatus_Failed():
        sse_encode_i_32(4, serializer);
    }
  }

  @protected
  void sse_encode_firmware_info(FirmwareInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.label, serializer);
    sse_encode_i_64(self.time, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt64(self);
  }

  @protected
  void sse_encode_list_local_firmware(
      List<LocalFirmware> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_local_firmware(item, serializer);
    }
  }

  @protected
  void sse_encode_list_module_config(
      List<ModuleConfig> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_module_config(item, serializer);
    }
  }

  @protected
  void sse_encode_list_nearby_station(
      List<NearbyStation> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_nearby_station(item, serializer);
    }
  }

  @protected
  void sse_encode_list_network_config(
      List<NetworkConfig> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_network_config(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_archive(
      List<RecordArchive> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_archive(item, serializer);
    }
  }

  @protected
  void sse_encode_list_sensor_config(
      List<SensorConfig> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_sensor_config(item, serializer);
    }
  }

  @protected
  void sse_encode_list_station_config(
      List<StationConfig> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_station_config(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wifi_network_config(
      List<WifiNetworkConfig> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wifi_network_config(item, serializer);
    }
  }

  @protected
  void sse_encode_local_firmware(LocalFirmware self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.label, serializer);
    sse_encode_i_64(self.time, serializer);
    sse_encode_String(self.module, serializer);
    sse_encode_String(self.profile, serializer);
  }

  @protected
  void sse_encode_lora_band(LoraBand self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_lora_config(LoraConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.available, serializer);
    sse_encode_lora_band(self.band, serializer);
    sse_encode_list_prim_u_8_strict(self.deviceEui, serializer);
    sse_encode_list_prim_u_8_strict(self.appKey, serializer);
    sse_encode_list_prim_u_8_strict(self.joinEui, serializer);
    sse_encode_list_prim_u_8_strict(self.deviceAddress, serializer);
    sse_encode_list_prim_u_8_strict(self.networkSessionKey, serializer);
    sse_encode_list_prim_u_8_strict(self.appSessionKey, serializer);
  }

  @protected
  void sse_encode_lora_transmission_config(
      LoraTransmissionConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_32(self.band, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.appKey, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.joinEui, serializer);
    sse_encode_opt_box_autoadd_schedule(self.schedule, serializer);
  }

  @protected
  void sse_encode_module_config(ModuleConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.position, serializer);
    sse_encode_String(self.moduleId, serializer);
    sse_encode_String(self.key, serializer);
    sse_encode_list_sensor_config(self.sensors, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.configuration, serializer);
  }

  @protected
  void sse_encode_name_config(NameConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
  }

  @protected
  void sse_encode_nearby_station(NearbyStation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.deviceId, serializer);
    sse_encode_bool(self.busy, serializer);
  }

  @protected
  void sse_encode_network_config(NetworkConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.index, serializer);
    sse_encode_String(self.ssid, serializer);
    sse_encode_bool(self.preferred, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_deployment_config(
      DeploymentConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_deployment_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ephemeral_config(
      EphemeralConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ephemeral_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_lora_config(
      LoraConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_lora_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_schedule(
      Schedule? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_schedule(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_sensor_value(
      SensorValue? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_sensor_value(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_tokens(
      Tokens? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_tokens(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_transmission_config(
      TransmissionConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_transmission_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(
      Uint8List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_portal_error(PortalError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PortalError_Authentication():
        sse_encode_i_32(0, serializer);
      case PortalError_Connecting():
        sse_encode_i_32(1, serializer);
      case PortalError_Other(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_String(field0, serializer);
      case PortalError_Sdk():
        sse_encode_i_32(3, serializer);
    }
  }

  @protected
  void sse_encode_record_archive(RecordArchive self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.deviceId, serializer);
    sse_encode_String(self.generationId, serializer);
    sse_encode_String(self.path, serializer);
    sse_encode_i_64(self.head, serializer);
    sse_encode_i_64(self.tail, serializer);
    sse_encode_opt_box_autoadd_i_64(self.uploaded, serializer);
  }

  @protected
  void sse_encode_registered(Registered self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.email, serializer);
    sse_encode_String(self.name, serializer);
  }

  @protected
  void sse_encode_schedule(Schedule self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Schedule_Every(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_u_32(field0, serializer);
    }
  }

  @protected
  void sse_encode_sensor_config(SensorConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.number, serializer);
    sse_encode_String(self.key, serializer);
    sse_encode_String(self.fullKey, serializer);
    sse_encode_String(self.calibratedUom, serializer);
    sse_encode_String(self.uncalibratedUom, serializer);
    sse_encode_opt_box_autoadd_sensor_value(self.value, serializer);
    sse_encode_opt_box_autoadd_sensor_value(self.previousValue, serializer);
  }

  @protected
  void sse_encode_sensor_value(SensorValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_utc_date_time(self.time, serializer);
    sse_encode_f_32(self.value, serializer);
    sse_encode_f_32(self.uncalibrated, serializer);
  }

  @protected
  void sse_encode_solar_info(SolarInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.voltage, serializer);
  }

  @protected
  void sse_encode_station_config(StationConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.deviceId, serializer);
    sse_encode_String(self.generationId, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_firmware_info(self.firmware, serializer);
    sse_encode_utc_date_time(self.lastSeen, serializer);
    sse_encode_stream_info(self.meta, serializer);
    sse_encode_stream_info(self.data, serializer);
    sse_encode_battery_info(self.battery, serializer);
    sse_encode_solar_info(self.solar, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.pb, serializer);
    sse_encode_list_module_config(self.modules, serializer);
  }

  @protected
  void sse_encode_stream_info(StreamInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.size, serializer);
    sse_encode_u_64(self.records, serializer);
  }

  @protected
  void sse_encode_tokens(Tokens self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.token, serializer);
    sse_encode_transmission_token(self.transmission, serializer);
  }

  @protected
  void sse_encode_transfer_progress(
      TransferProgress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.deviceId, serializer);
    sse_encode_transfer_status(self.status, serializer);
  }

  @protected
  void sse_encode_transfer_status(
      TransferStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case TransferStatus_Starting():
        sse_encode_i_32(0, serializer);
      case TransferStatus_Downloading(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_download_progress(field0, serializer);
      case TransferStatus_Uploading(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_upload_progress(field0, serializer);
      case TransferStatus_Processing():
        sse_encode_i_32(3, serializer);
      case TransferStatus_Completed():
        sse_encode_i_32(4, serializer);
      case TransferStatus_Failed():
        sse_encode_i_32(5, serializer);
    }
  }

  @protected
  void sse_encode_transmission_config(
      TransmissionConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.enabled, serializer);
  }

  @protected
  void sse_encode_transmission_token(
      TransmissionToken self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.token, serializer);
    sse_encode_String(self.url, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_upgrade_progress(
      UpgradeProgress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.deviceId, serializer);
    sse_encode_i_64(self.firmwareId, serializer);
    sse_encode_upgrade_status(self.status, serializer);
  }

  @protected
  void sse_encode_upgrade_status(UpgradeStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case UpgradeStatus_Starting():
        sse_encode_i_32(0, serializer);
      case UpgradeStatus_Uploading(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_upload_progress(field0, serializer);
      case UpgradeStatus_Restarting():
        sse_encode_i_32(2, serializer);
      case UpgradeStatus_ReconnectTimeout():
        sse_encode_i_32(3, serializer);
      case UpgradeStatus_Completed():
        sse_encode_i_32(4, serializer);
      case UpgradeStatus_Failed():
        sse_encode_i_32(5, serializer);
    }
  }

  @protected
  void sse_encode_upload_progress(
      UploadProgress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.bytesUploaded, serializer);
    sse_encode_u_64(self.totalBytes, serializer);
  }

  @protected
  void sse_encode_usize(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_utc_date_time(UtcDateTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.field0, serializer);
  }

  @protected
  void sse_encode_wifi_network_config(
      WifiNetworkConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.index, serializer);
    sse_encode_opt_String(self.ssid, serializer);
    sse_encode_opt_String(self.password, serializer);
    sse_encode_bool(self.preferred, serializer);
    sse_encode_bool(self.keeping, serializer);
  }

  @protected
  void sse_encode_wifi_networks_config(
      WifiNetworksConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_wifi_network_config(self.networks, serializer);
  }

  @protected
  void sse_encode_wifi_transmission_config(
      WifiTransmissionConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_tokens(self.tokens, serializer);
    sse_encode_opt_box_autoadd_schedule(self.schedule, serializer);
  }
}
