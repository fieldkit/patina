// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.82.1.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty, unnecessary_const

import 'bridge_generated.io.dart'
    if (dart.library.html) 'bridge_generated.web.dart';
import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:uuid/uuid.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;

part 'bridge_definitions.freezed.dart';

abstract class Native {
  Stream<DomainMessage> startNative(
      {required String storagePath,
      required String portalBaseUrl,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStartNativeConstMeta;

  Future<List<StationConfig>> getMyStations({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetMyStationsConstMeta;

  Future<Authenticated> authenticatePortal(
      {required String email, required String password, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAuthenticatePortalConstMeta;

  Future<Registered> registerPortalAccount(
      {required String email,
      required String password,
      required String name,
      required bool tncAccount,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRegisterPortalAccountConstMeta;

  Future<int?> addOrUpdateStationInPortal(
      {required Tokens tokens,
      required AddOrUpdatePortalStation station,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAddOrUpdateStationInPortalConstMeta;

  Future<void> configureDeploy(
      {required String deviceId, required DeployConfig config, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kConfigureDeployConstMeta;

  Future<void> configureWifiNetworks(
      {required String deviceId,
      required WifiNetworksConfig config,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kConfigureWifiNetworksConstMeta;

  Future<void> configureWifiTransmission(
      {required String deviceId,
      required WifiTransmissionConfig config,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kConfigureWifiTransmissionConstMeta;

  Future<void> configureLoraTransmission(
      {required String deviceId,
      required LoraTransmissionConfig config,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kConfigureLoraTransmissionConstMeta;

  Future<void> verifyLoraTransmission({required String deviceId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kVerifyLoraTransmissionConstMeta;

  Future<void> clearCalibration(
      {required String deviceId, required int module, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kClearCalibrationConstMeta;

  Future<void> calibrate(
      {required String deviceId,
      required int module,
      required Uint8List data,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCalibrateConstMeta;

  Future<Authenticated> validateTokens({required Tokens tokens, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kValidateTokensConstMeta;

  Future<TransferProgress> startDownload(
      {required String deviceId, int? first, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStartDownloadConstMeta;

  Future<TransferProgress> startUpload(
      {required String deviceId,
      required Tokens tokens,
      required List<RecordArchive> files,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStartUploadConstMeta;

  Future<FirmwareDownloadStatus> cacheFirmware({Tokens? tokens, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCacheFirmwareConstMeta;

  Future<UpgradeProgress> upgradeStation(
      {required String deviceId,
      required LocalFirmware firmware,
      required bool swap,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kUpgradeStationConstMeta;

  Future<bool> rustReleaseMode({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRustReleaseModeConstMeta;

  Stream<String> createLogSink({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateLogSinkConstMeta;
}

class AddOrUpdatePortalStation {
  final String name;
  final String deviceId;
  final String locationName;
  final String statusPb;

  const AddOrUpdatePortalStation({
    required this.name,
    required this.deviceId,
    required this.locationName,
    required this.statusPb,
  });
}

class Authenticated {
  final String email;
  final String name;
  final Tokens tokens;

  const Authenticated({
    required this.email,
    required this.name,
    required this.tokens,
  });
}

class BatteryInfo {
  final double percentage;
  final double voltage;

  const BatteryInfo({
    required this.percentage,
    required this.voltage,
  });
}

class DeployConfig {
  final String location;
  final int deployed;
  final Schedule schedule;

  const DeployConfig({
    required this.location,
    required this.deployed,
    required this.schedule,
  });
}

class DeviceCapabilities {
  final bool udp;

  const DeviceCapabilities({
    required this.udp,
  });
}

@freezed
sealed class DomainMessage with _$DomainMessage {
  const factory DomainMessage.preAccount() = DomainMessage_PreAccount;
  const factory DomainMessage.nearbyStations(
    List<NearbyStation> field0,
  ) = DomainMessage_NearbyStations;
  const factory DomainMessage.stationRefreshed(
    StationConfig field0,
    EphemeralConfig? field1,
    String field2,
  ) = DomainMessage_StationRefreshed;
  const factory DomainMessage.uploadProgress(
    TransferProgress field0,
  ) = DomainMessage_UploadProgress;
  const factory DomainMessage.downloadProgress(
    TransferProgress field0,
  ) = DomainMessage_DownloadProgress;
  const factory DomainMessage.firmwareDownloadStatus(
    FirmwareDownloadStatus field0,
  ) = DomainMessage_FirmwareDownloadStatus;
  const factory DomainMessage.upgradeProgress(
    UpgradeProgress field0,
  ) = DomainMessage_UpgradeProgress;
  const factory DomainMessage.availableFirmware(
    List<LocalFirmware> field0,
  ) = DomainMessage_AvailableFirmware;
  const factory DomainMessage.recordArchives(
    List<RecordArchive> field0,
  ) = DomainMessage_RecordArchives;
}

class DownloadProgress {
  final int started;
  final double completed;
  final int total;
  final int received;

  const DownloadProgress({
    required this.started,
    required this.completed,
    required this.total,
    required this.received,
  });
}

class EphemeralConfig {
  final TransmissionConfig? transmission;
  final List<NetworkConfig> networks;
  final LoraConfig? lora;
  final DeviceCapabilities capabilities;
  final Uint8List events;

  const EphemeralConfig({
    this.transmission,
    required this.networks,
    this.lora,
    required this.capabilities,
    required this.events,
  });
}

@freezed
sealed class FirmwareDownloadStatus with _$FirmwareDownloadStatus {
  const factory FirmwareDownloadStatus.checking() =
      FirmwareDownloadStatus_Checking;
  const factory FirmwareDownloadStatus.downloading(
    DownloadProgress field0,
  ) = FirmwareDownloadStatus_Downloading;
  const factory FirmwareDownloadStatus.offline() =
      FirmwareDownloadStatus_Offline;
  const factory FirmwareDownloadStatus.completed() =
      FirmwareDownloadStatus_Completed;
  const factory FirmwareDownloadStatus.failed() = FirmwareDownloadStatus_Failed;
}

class FirmwareInfo {
  final String label;
  final int time;

  const FirmwareInfo({
    required this.label,
    required this.time,
  });
}

class LocalFirmware {
  final int id;
  final String label;
  final int time;
  final String module;
  final String profile;

  const LocalFirmware({
    required this.id,
    required this.label,
    required this.time,
    required this.module,
    required this.profile,
  });
}

enum LoraBand {
  F915Mhz,
  F868Mhz,
}

class LoraConfig {
  final bool available;
  final LoraBand band;
  final Uint8List deviceEui;
  final Uint8List appKey;
  final Uint8List joinEui;
  final Uint8List deviceAddress;
  final Uint8List networkSessionKey;
  final Uint8List appSessionKey;

  const LoraConfig({
    required this.available,
    required this.band,
    required this.deviceEui,
    required this.appKey,
    required this.joinEui,
    required this.deviceAddress,
    required this.networkSessionKey,
    required this.appSessionKey,
  });
}

class LoraTransmissionConfig {
  final int? band;
  final Uint8List? appKey;
  final Uint8List? joinEui;
  final Schedule? schedule;

  const LoraTransmissionConfig({
    this.band,
    this.appKey,
    this.joinEui,
    this.schedule,
  });
}

class ModuleConfig {
  final int position;
  final String moduleId;
  final String key;
  final List<SensorConfig> sensors;
  final Uint8List? configuration;

  const ModuleConfig({
    required this.position,
    required this.moduleId,
    required this.key,
    required this.sensors,
    this.configuration,
  });
}

class NearbyStation {
  final String deviceId;
  final bool busy;

  const NearbyStation({
    required this.deviceId,
    required this.busy,
  });
}

class NetworkConfig {
  final int index;
  final String ssid;
  final bool preferred;

  const NetworkConfig({
    required this.index,
    required this.ssid,
    required this.preferred,
  });
}

@freezed
sealed class PortalError with _$PortalError implements FrbException {
  const factory PortalError.authentication() = PortalError_Authentication;
  const factory PortalError.connecting() = PortalError_Connecting;
  const factory PortalError.other(
    String field0,
  ) = PortalError_Other;
}

class RecordArchive {
  final String deviceId;
  final String generationId;
  final String path;
  final int head;
  final int tail;

  const RecordArchive({
    required this.deviceId,
    required this.generationId,
    required this.path,
    required this.head,
    required this.tail,
  });
}

class Registered {
  final String email;
  final String name;

  const Registered({
    required this.email,
    required this.name,
  });
}

@freezed
sealed class Schedule with _$Schedule {
  const factory Schedule.every(
    int field0,
  ) = Schedule_Every;
}

class SensorConfig {
  final int number;
  final String key;
  final String fullKey;
  final String calibratedUom;
  final String uncalibratedUom;
  final SensorValue? value;

  const SensorConfig({
    required this.number,
    required this.key,
    required this.fullKey,
    required this.calibratedUom,
    required this.uncalibratedUom,
    this.value,
  });
}

class SensorValue {
  final DateTime time;
  final double value;
  final double uncalibrated;

  const SensorValue({
    required this.time,
    required this.value,
    required this.uncalibrated,
  });
}

class SolarInfo {
  final double voltage;

  const SolarInfo({
    required this.voltage,
  });
}

class StationConfig {
  final String deviceId;
  final String generationId;
  final String name;
  final FirmwareInfo firmware;
  final DateTime lastSeen;
  final StreamInfo meta;
  final StreamInfo data;
  final BatteryInfo battery;
  final SolarInfo solar;
  final List<ModuleConfig> modules;

  const StationConfig({
    required this.deviceId,
    required this.generationId,
    required this.name,
    required this.firmware,
    required this.lastSeen,
    required this.meta,
    required this.data,
    required this.battery,
    required this.solar,
    required this.modules,
  });
}

class StreamInfo {
  final int size;
  final int records;

  const StreamInfo({
    required this.size,
    required this.records,
  });
}

class Tokens {
  final String token;
  final TransmissionToken transmission;

  const Tokens({
    required this.token,
    required this.transmission,
  });
}

class TransferProgress {
  final String deviceId;
  final TransferStatus status;

  const TransferProgress({
    required this.deviceId,
    required this.status,
  });
}

@freezed
sealed class TransferStatus with _$TransferStatus {
  const factory TransferStatus.starting() = TransferStatus_Starting;
  const factory TransferStatus.downloading(
    DownloadProgress field0,
  ) = TransferStatus_Downloading;
  const factory TransferStatus.uploading(
    UploadProgress field0,
  ) = TransferStatus_Uploading;
  const factory TransferStatus.processing() = TransferStatus_Processing;
  const factory TransferStatus.completed() = TransferStatus_Completed;
  const factory TransferStatus.failed() = TransferStatus_Failed;
}

class TransmissionConfig {
  final bool enabled;

  const TransmissionConfig({
    required this.enabled,
  });
}

class TransmissionToken {
  final String token;
  final String url;

  const TransmissionToken({
    required this.token,
    required this.url,
  });
}

class UpgradeProgress {
  final String deviceId;
  final int firmwareId;
  final UpgradeStatus status;

  const UpgradeProgress({
    required this.deviceId,
    required this.firmwareId,
    required this.status,
  });
}

@freezed
sealed class UpgradeStatus with _$UpgradeStatus {
  const factory UpgradeStatus.starting() = UpgradeStatus_Starting;
  const factory UpgradeStatus.uploading(
    UploadProgress field0,
  ) = UpgradeStatus_Uploading;
  const factory UpgradeStatus.restarting() = UpgradeStatus_Restarting;
  const factory UpgradeStatus.completed() = UpgradeStatus_Completed;
  const factory UpgradeStatus.failed() = UpgradeStatus_Failed;
}

class UploadProgress {
  final int bytesUploaded;
  final int totalBytes;

  const UploadProgress({
    required this.bytesUploaded,
    required this.totalBytes,
  });
}

class WifiNetworkConfig {
  final int index;
  final String? ssid;
  final String? password;
  final bool preferred;
  final bool keeping;

  const WifiNetworkConfig({
    required this.index,
    this.ssid,
    this.password,
    required this.preferred,
    required this.keeping,
  });
}

class WifiNetworksConfig {
  final List<WifiNetworkConfig> networks;

  const WifiNetworksConfig({
    required this.networks,
  });
}

class WifiTransmissionConfig {
  final Tokens? tokens;
  final Schedule? schedule;

  const WifiTransmissionConfig({
    this.tokens,
    this.schedule,
  });
}
