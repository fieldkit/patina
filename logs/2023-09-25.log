2023/09/25 13:28:57 [[34mDEBUG[0m] configs=[Opts { rust_input_path: "/home/kate/Documents/GitLab/patina/native/src/api.rs", dart_output_path: "/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.dart", dart_decl_output_path: Some("/home/kate/Documents/GitLab/patina/lib/gen/bridge_definitions.dart"), c_output_path: ["/home/kate/Documents/GitLab/patina/macos/Runner/bridge_generated.h", "ios/Runner/bridge_generated.h"], rust_crate_dir: "/home/kate/Documents/GitLab/patina/native", rust_output_path: "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.rs", class_name: "Native", dart_format_line_length: 80, dart_enums_style: false, skip_add_mod_to_lib: false, llvm_path: ["/opt/homebrew/opt/llvm", "/usr/local/opt/llvm", "/usr/lib/llvm-9", "/usr/lib/llvm-10", "/usr/lib/llvm-11", "/usr/lib/llvm-12", "/usr/lib/llvm-13", "/usr/lib/llvm-14", "/usr/lib/", "/usr/lib64/", "C:/Program Files/llvm", "C:/msys64/mingw64"], llvm_compiler_opts: "", manifest_path: "/home/kate/Documents/GitLab/patina/native/Cargo.toml", dart_root: Some("/home/kate/Documents/GitLab/patina"), build_runner: true, block_index: BlockIndex(0), skip_deps_check: false, wasm_enabled: true, inline_rust: false, bridge_in_method: true, extra_headers: "", dart3: true, keep_going: false }]
2023/09/25 13:28:57 [[32mINFO[0m] Running cargo expand in '/home/kate/Documents/GitLab/patina/native'
2023/09/25 13:28:57 [[34mDEBUG[0m] execute command: bin=cargo args="expand --theme=none --ugly" current_dir=Some("/home/kate/Documents/GitLab/patina/native") cmd=cd "/home/kate/Documents/GitLab/patina/native" && "cargo" "expand" "--theme=none" "--ugly"
2023/09/25 13:29:15 [[34mDEBUG[0m] command=cd "/home/kate/Documents/GitLab/patina/native" && "cargo" "expand" "--theme=none" "--ugly" stdout=#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod api {
    use anyhow::{bail, Result};
    use chrono::{DateTime, Utc};
    use flutter_rust_bridge::StreamSink;
    use std::{
        io::Write, path::{Path, PathBuf},
        sync::{Arc, Mutex as StdMutex},
    };
    use sync::{FilesRecordSink, Server, ServerEvent, UdpTransport};
    use thiserror::Error;
    use tokio::sync::{mpsc::Sender, oneshot, Mutex};
    use tokio::{runtime::Runtime, sync::mpsc::Receiver};
    use tokio_stream::StreamExt;
    use tracing::*;
    use tracing_subscriber::{fmt::MakeWriter, EnvFilter};
    use discovery::{DeviceId, Discovered, Discovery};
    use query::{
        device::{self, HttpReply},
        portal::{DecodedToken, PortalError, StatusCode},
    };
    use store::Db;
    use crate::nearby::{BackgroundMessage, Connection, NearbyDevices};
    static SDK: StdMutex<Option<Sdk>> = StdMutex::new(None);
    static RUNTIME: StdMutex<Option<Runtime>> = StdMutex::new(None);
    struct MergeAndPublishReplies {
        db: Arc<Mutex<Db>>,
        publish_tx: Sender<DomainMessage>,
    }
    impl MergeAndPublishReplies {
        fn new(db: Arc<Mutex<Db>>, publish_tx: Sender<DomainMessage>)
            -> Self {
            Self { db, publish_tx }
        }
        async fn handle_background_message(&self, bg: BackgroundMessage)
            -> Result<()> {
            match bg {
                BackgroundMessage::Domain(message) =>
                    Ok(self.publish_tx.send(message).await?),
                BackgroundMessage::StationReply(device_id, reply, raw) => {
                    let station =
                        {
                            let db = self.db.lock().await;
                            db.merge_reply(store::DeviceId(device_id.0), reply.clone())?
                        };
                    Ok(self.publish_tx.send(DomainMessage::StationRefreshed(StationAndConnection {
                                                    station,
                                                    connection: Some(Connection::Connected),
                                                }.try_into()?, Some(reply.try_into()?), raw)).await?)
                }
            }
        }
        async fn run(&self, mut bg_rx: Receiver<BackgroundMessage>) {
            while let Some(bg) = bg_rx.recv().await {
                match self.handle_background_message(bg).await {
                    Err(e) => {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/api.rs:67",
                                            "native::api", ::tracing::Level::WARN, Some("src/api.rs"),
                                            Some(67u32), Some("native::api"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::WARN <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::WARN <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("Errr handling background: {0:?}", e) as
                                                                    &dyn Value))])
                                    });
                            } else { ; }
                    }
                    Ok(_) => {}
                }
            }
        }
    }
    async fn create_sdk(storage_path: String, portal_base_url: String,
        publish_tx: Sender<DomainMessage>) -> Result<Sdk> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite =
                {
                    static META: ::tracing::Metadata<'static> =
                        {
                            ::tracing_core::metadata::Metadata::new("event src/api.rs:79",
                                "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                Some(79u32), Some("native::api"),
                                ::tracing_core::field::FieldSet::new(&["message"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE)),
                                ::tracing::metadata::Kind::EVENT)
                        };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
            let enabled =
                ::tracing::Level::INFO <=
                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                        ::tracing::Level::INFO <=
                            ::tracing::level_filters::LevelFilter::current() &&
                    {
                        let interest = CALLSITE.interest();
                        !interest.is_never() &&
                            ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                interest)
                    };
            if enabled {
                    (|value_set: ::tracing::field::ValueSet|
                                {
                                    let meta = CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    ;
                                })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = CALLSITE.metadata().fields().iter();
                            CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&format_args!("startup:bg") as &dyn Value))])
                        });
                } else { ; }
        };
        let (bg_tx, bg_rx) =
            tokio::sync::mpsc::channel::<BackgroundMessage>(32);
        let nearby = NearbyDevices::new(bg_tx.clone());
        let server =
            Arc::new(Server::new(UdpTransport::new(),
                    FilesRecordSink::new(&Path::new(&storage_path).join("fk-data"))));
        let sdk =
            Sdk::new(storage_path, portal_base_url, nearby.clone(),
                    server.clone(), publish_tx.clone())?;
        let db = sdk.open().await?;
        let merge = MergeAndPublishReplies::new(db, publish_tx.clone());
        tokio::spawn(async move
                { background_task(nearby, server, merge, bg_rx).await });
        Ok(sdk)
    }
    async fn background_task(nearby: NearbyDevices,
        server: Arc<Server<UdpTransport, FilesRecordSink>>,
        merge: MergeAndPublishReplies, bg_rx: Receiver<BackgroundMessage>) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite =
                {
                    static META: ::tracing::Metadata<'static> =
                        {
                            ::tracing_core::metadata::Metadata::new("event src/api.rs:113",
                                "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                Some(113u32), Some("native::api"),
                                ::tracing_core::field::FieldSet::new(&["message"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE)),
                                ::tracing::metadata::Kind::EVENT)
                        };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
            let enabled =
                ::tracing::Level::INFO <=
                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                        ::tracing::Level::INFO <=
                            ::tracing::level_filters::LevelFilter::current() &&
                    {
                        let interest = CALLSITE.interest();
                        !interest.is_never() &&
                            ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                interest)
                    };
            if enabled {
                    (|value_set: ::tracing::field::ValueSet|
                                {
                                    let meta = CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    ;
                                })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = CALLSITE.metadata().fields().iter();
                            CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&format_args!("bg:started") as &dyn Value))])
                        });
                } else { ; }
        };
        let (transfer_publish, transfer_events) =
            tokio::sync::mpsc::channel::<ServerEvent>(32);
        let (discovery_tx, discovery_rx) =
            tokio::sync::mpsc::channel::<Discovered>(8);
        let discovery = Discovery::default();
        {
            #[doc(hidden)]
            mod __tokio_select_util {
                pub(super) enum Out<_0, _1, _2, _3> {
                    _0(_0),
                    _1(_1),
                    _2(_2),
                    _3(_3),
                    Disabled,
                }
                pub(super) type Mask = u8;
            }
            use ::tokio::macros::support::Future;
            use ::tokio::macros::support::Pin;
            use ::tokio::macros::support::Poll::{Ready, Pending};
            const BRANCHES: u32 = 4;
            let mut disabled: __tokio_select_util::Mask = Default::default();
            if !true {
                    let mask: __tokio_select_util::Mask = 1 << 0;
                    disabled |= mask;
                }
            if !true {
                    let mask: __tokio_select_util::Mask = 1 << 1;
                    disabled |= mask;
                }
            if !true {
                    let mask: __tokio_select_util::Mask = 1 << 2;
                    disabled |= mask;
                }
            if !true {
                    let mask: __tokio_select_util::Mask = 1 << 3;
                    disabled |= mask;
                }
            let mut output =
                {
                    let mut futures =
                        (discovery.run(discovery_tx),
                            nearby.run(discovery_rx, transfer_events),
                            server.run(transfer_publish), merge.run(bg_rx));
                    let mut futures = &mut futures;
                    ::tokio::macros::support::poll_fn(|cx|
                                {
                                    let mut is_pending = false;
                                    let start =
                                        { ::tokio::macros::support::thread_rng_n(BRANCHES) };
                                    for i in 0..BRANCHES {
                                        let branch;

                                        #[allow(clippy :: modulo_one)]
                                        { branch = (start + i) % BRANCHES; }
                                        match branch
                                            {
                                                #[allow(unreachable_code)]
                                                0 => {
                                                let mask = 1 << branch;
                                                if disabled & mask == mask { continue; }
                                                let (fut, ..) = &mut *futures;
                                                let mut fut = unsafe { Pin::new_unchecked(fut) };
                                                let out =
                                                    match Future::poll(fut, cx) {
                                                        Ready(out) => out,
                                                        Pending => { is_pending = true; continue; }
                                                    };
                                                disabled |= mask;

                                                #[allow(unused_variables)]
                                                #[allow(unused_mut)]
                                                match &out { _ => {} _ => continue, }
                                                return Ready(__tokio_select_util::Out::_0(out));
                                            }
                                                #[allow(unreachable_code)]
                                                1 => {
                                                let mask = 1 << branch;
                                                if disabled & mask == mask { continue; }
                                                let (_, fut, ..) = &mut *futures;
                                                let mut fut = unsafe { Pin::new_unchecked(fut) };
                                                let out =
                                                    match Future::poll(fut, cx) {
                                                        Ready(out) => out,
                                                        Pending => { is_pending = true; continue; }
                                                    };
                                                disabled |= mask;

                                                #[allow(unused_variables)]
                                                #[allow(unused_mut)]
                                                match &out { _ => {} _ => continue, }
                                                return Ready(__tokio_select_util::Out::_1(out));
                                            }
                                                #[allow(unreachable_code)]
                                                2 => {
                                                let mask = 1 << branch;
                                                if disabled & mask == mask { continue; }
                                                let (_, _, fut, ..) = &mut *futures;
                                                let mut fut = unsafe { Pin::new_unchecked(fut) };
                                                let out =
                                                    match Future::poll(fut, cx) {
                                                        Ready(out) => out,
                                                        Pending => { is_pending = true; continue; }
                                                    };
                                                disabled |= mask;

                                                #[allow(unused_variables)]
                                                #[allow(unused_mut)]
                                                match &out { _ => {} _ => continue, }
                                                return Ready(__tokio_select_util::Out::_2(out));
                                            }
                                                #[allow(unreachable_code)]
                                                3 => {
                                                let mask = 1 << branch;
                                                if disabled & mask == mask { continue; }
                                                let (_, _, _, fut, ..) = &mut *futures;
                                                let mut fut = unsafe { Pin::new_unchecked(fut) };
                                                let out =
                                                    match Future::poll(fut, cx) {
                                                        Ready(out) => out,
                                                        Pending => { is_pending = true; continue; }
                                                    };
                                                disabled |= mask;

                                                #[allow(unused_variables)]
                                                #[allow(unused_mut)]
                                                match &out { _ => {} _ => continue, }
                                                return Ready(__tokio_select_util::Out::_3(out));
                                            }
                                            _ => {
                                                ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                                        format_args!("reaching this means there probably is an off by one bug")));
                                            }
                                        }
                                    }
                                    if is_pending {
                                            Pending
                                        } else { Ready(__tokio_select_util::Out::Disabled) }
                                }).await
                };
            match output {
                __tokio_select_util::Out::_0(_) => {}
                __tokio_select_util::Out::_1(_) => {}
                __tokio_select_util::Out::_2(_) => {}
                __tokio_select_util::Out::_3(_) => {}
                __tokio_select_util::Out::Disabled => {
                    ::core::panicking::panic_fmt(format_args!("all branches are disabled and there is no else branch"));
                }
                _ => {
                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                            format_args!("failed to match bind")));
                }
            }
        };
    }
    pub fn start_native(storage_path: String, portal_base_url: String,
        sink: StreamSink<DomainMessage>) -> Result<()> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite =
                {
                    static META: ::tracing::Metadata<'static> =
                        {
                            ::tracing_core::metadata::Metadata::new("event src/api.rs:132",
                                "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                Some(132u32), Some("native::api"),
                                ::tracing_core::field::FieldSet::new(&["message"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE)),
                                ::tracing::metadata::Kind::EVENT)
                        };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
            let enabled =
                ::tracing::Level::INFO <=
                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                        ::tracing::Level::INFO <=
                            ::tracing::level_filters::LevelFilter::current() &&
                    {
                        let interest = CALLSITE.interest();
                        !interest.is_never() &&
                            ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                interest)
                    };
            if enabled {
                    (|value_set: ::tracing::field::ValueSet|
                                {
                                    let meta = CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    ;
                                })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = CALLSITE.metadata().fields().iter();
                            CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&format_args!("startup:runtime") as &dyn Value))])
                        });
                } else { ; }
        };
        let rt = start_runtime()?;
        let (publish_tx, mut publish_rx) = tokio::sync::mpsc::channel(20);
        let sdk =
            rt.block_on(create_sdk(storage_path, portal_base_url,
                        publish_tx))?;
        sink.add(DomainMessage::PreAccount);
        let handle = rt.handle().clone();
        {
            *SDK.lock().expect("Set sdk") = Some(sdk);
            *RUNTIME.lock().expect("Set runtime") = Some(rt);
        }
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite =
                {
                    static META: ::tracing::Metadata<'static> =
                        {
                            ::tracing_core::metadata::Metadata::new("event src/api.rs:150",
                                "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                Some(150u32), Some("native::api"),
                                ::tracing_core::field::FieldSet::new(&["message"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE)),
                                ::tracing::metadata::Kind::EVENT)
                        };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
            let enabled =
                ::tracing::Level::INFO <=
                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                        ::tracing::Level::INFO <=
                            ::tracing::level_filters::LevelFilter::current() &&
                    {
                        let interest = CALLSITE.interest();
                        !interest.is_never() &&
                            ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                interest)
                    };
            if enabled {
                    (|value_set: ::tracing::field::ValueSet|
                                {
                                    let meta = CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    ;
                                })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = CALLSITE.metadata().fields().iter();
                            CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&format_args!("startup:pump") as &dyn Value))])
                        });
                } else { ; }
        };
        let (tx, rx) = oneshot::channel();
        let _guard = handle.enter();
        tokio::spawn(async move
                {
                while let Some(e) = publish_rx.recv().await {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/api.rs:158",
                                            "native::api", ::tracing::Level::TRACE, Some("src/api.rs"),
                                            Some(158u32), Some("native::api"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::TRACE <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::TRACE <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("sdk:publish") as &dyn Value))])
                                    });
                            } else { ; }
                    };
                    sink.add(e.into());
                }
                let _ = tx.send(());
            });
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite =
                {
                    static META: ::tracing::Metadata<'static> =
                        {
                            ::tracing_core::metadata::Metadata::new("event src/api.rs:163",
                                "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                Some(163u32), Some("native::api"),
                                ::tracing_core::field::FieldSet::new(&["message"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE)),
                                ::tracing::metadata::Kind::EVENT)
                        };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
            let enabled =
                ::tracing::Level::INFO <=
                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                        ::tracing::Level::INFO <=
                            ::tracing::level_filters::LevelFilter::current() &&
                    {
                        let interest = CALLSITE.interest();
                        !interest.is_never() &&
                            ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                interest)
                    };
            if enabled {
                    (|value_set: ::tracing::field::ValueSet|
                                {
                                    let meta = CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    ;
                                })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = CALLSITE.metadata().fields().iter();
                            CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&format_args!("sdk:ready") as &dyn Value))])
                        });
                } else { ; }
        };
        let _ = rx.blocking_recv();
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite =
                {
                    static META: ::tracing::Metadata<'static> =
                        {
                            ::tracing_core::metadata::Metadata::new("event src/api.rs:166",
                                "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                Some(166u32), Some("native::api"),
                                ::tracing_core::field::FieldSet::new(&["message"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE)),
                                ::tracing::metadata::Kind::EVENT)
                        };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
            let enabled =
                ::tracing::Level::INFO <=
                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                        ::tracing::Level::INFO <=
                            ::tracing::level_filters::LevelFilter::current() &&
                    {
                        let interest = CALLSITE.interest();
                        !interest.is_never() &&
                            ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                interest)
                    };
            if enabled {
                    (|value_set: ::tracing::field::ValueSet|
                                {
                                    let meta = CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    ;
                                })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = CALLSITE.metadata().fields().iter();
                            CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&format_args!("sdk:finished") as &dyn Value))])
                        });
                } else { ; }
        };
        Ok(())
    }
    #[allow(dead_code)]
    struct Sdk {
        storage_path: String,
        portal_base_url: String,
        db: Arc<Mutex<Db>>,
        nearby: NearbyDevices,
        server: Arc<Server<UdpTransport, FilesRecordSink>>,
        publish_tx: Sender<DomainMessage>,
    }
    impl Sdk {
        fn new(storage_path: String, portal_base_url: String,
            nearby: NearbyDevices,
            server: Arc<Server<UdpTransport, FilesRecordSink>>,
            publish_tx: Sender<DomainMessage>) -> Result<Self> {
            Ok(Self {
                    storage_path,
                    portal_base_url,
                    db: Arc::new(Mutex::new(Db::new())),
                    nearby,
                    server,
                    publish_tx,
                })
        }
        async fn open(&self) -> Result<Arc<Mutex<Db>>> {
            let mut db = self.db.lock().await;
            db.open()?;
            Ok(self.db.clone())
        }
        async fn get_my_stations(&self) -> Result<Vec<StationConfig>> {
            let connections = self.nearby.get_connections().await?;
            let db = self.db.lock().await;
            let stations = db.get_stations()?;
            Ok(stations.into_iter().map(|station|
                                {
                                    let device_id = &DeviceId(station.device_id.clone().0);
                                    let connection = connections.get(&device_id).cloned();
                                    Ok(StationAndConnection { station, connection }.try_into()?)
                                }).collect::<Result<Vec<_>>>()?)
        }
        async fn authenticate_portal(&self, email: String, password: String)
            -> Result<Authenticated> {
            let client = query::portal::Client::new(&self.portal_base_url)?;
            let tokens =
                client.login(query::portal::LoginPayload {
                                email: email.clone(),
                                password,
                            }).await?;
            let authenticated = client.to_authenticated(tokens.clone())?;
            let ourselves = authenticated.query_ourselves().await?;
            let transmission =
                authenticated.issue_transmission_token().await?;
            Ok(Authenticated {
                    name: ourselves.name,
                    email,
                    tokens: Tokens::from(tokens, transmission),
                })
        }
        async fn add_or_update_station_in_portal(&self, tokens: Tokens,
            station: AddOrUpdatePortalStation) -> Result<Option<u32>> {
            let client = query::portal::Client::new(&self.portal_base_url)?;
            let authenticated = client.to_authenticated(tokens.into())?;
            Ok(authenticated.add_or_update_station(station.into()).await?.map(|s|
                        s.id))
        }
        async fn validate_tokens(&self, tokens: Tokens)
            -> Result<Authenticated> {
            let client = query::portal::Client::new(&self.portal_base_url)?;
            let client = client.to_authenticated(tokens.clone().into())?;
            let decoded = tokens.decoded()?;
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                    {
                        static META: ::tracing::Metadata<'static> =
                            {
                                ::tracing_core::metadata::Metadata::new("event src/api.rs:264",
                                    "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                    Some(264u32), Some("native::api"),
                                    ::tracing_core::field::FieldSet::new(&["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                    ::tracing::metadata::Kind::EVENT)
                            };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                let enabled =
                    ::tracing::Level::INFO <=
                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                            ::tracing::Level::INFO <=
                                ::tracing::level_filters::LevelFilter::current() &&
                        {
                            let interest = CALLSITE.interest();
                            !interest.is_never() &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest)
                        };
                if enabled {
                        (|value_set: ::tracing::field::ValueSet|
                                    {
                                        let meta = CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        ;
                                    })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&format_args!("expires={0:?} ({1} remaining) issued={2:?}",
                                                                    decoded.issued(), decoded.remaining(), decoded.expires()) as
                                                            &dyn Value))])
                            });
                    } else { ; }
            };
            match client.query_ourselves().await {
                Ok(ourselves) =>
                    Ok(Authenticated {
                            name: ourselves.name,
                            email: ourselves.email,
                            tokens,
                        }),
                Err(PortalError::HttpStatus(StatusCode::UNAUTHORIZED)) => {
                    Ok(self.refresh_tokens(tokens).await?)
                }
                Err(e) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/api.rs:281",
                                            "native::api", ::tracing::Level::WARN, Some("src/api.rs"),
                                            Some(281u32), Some("native::api"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::WARN <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::WARN <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("query error: {0:?}", e) as
                                                                    &dyn Value))])
                                    });
                            } else { ; }
                    };
                    Err(e.into())
                }
            }
        }
        async fn refresh_tokens(&self, tokens: Tokens)
            -> Result<Authenticated> {
            let refresh_token = tokens.refresh_token()?;
            let client = query::portal::Client::new(&self.portal_base_url)?;
            let refreshed = client.use_refresh_token(&refresh_token).await?;
            let authenticated = client.to_authenticated(refreshed.clone())?;
            let ourselves = authenticated.query_ourselves().await?;
            let transmission =
                authenticated.issue_transmission_token().await?;
            Ok(Authenticated {
                    name: ourselves.name,
                    email: ourselves.email,
                    tokens: Tokens::from(refreshed, transmission),
                })
        }
        async fn start_download(&self, device_id: DeviceId)
            -> Result<TransferProgress> {
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                    {
                        static META: ::tracing::Metadata<'static> =
                            {
                                ::tracing_core::metadata::Metadata::new("event src/api.rs:302",
                                    "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                    Some(302u32), Some("native::api"),
                                    ::tracing_core::field::FieldSet::new(&["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                    ::tracing::metadata::Kind::EVENT)
                            };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                let enabled =
                    ::tracing::Level::INFO <=
                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                            ::tracing::Level::INFO <=
                                ::tracing::level_filters::LevelFilter::current() &&
                        {
                            let interest = CALLSITE.interest();
                            !interest.is_never() &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest)
                        };
                if enabled {
                        (|value_set: ::tracing::field::ValueSet|
                                    {
                                        let meta = CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        ;
                                    })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&format_args!("{0:?} start download", &device_id) as
                                                            &dyn Value))])
                            });
                    } else { ; }
            };
            let discovered = self.nearby.get_discovered(&device_id).await;
            if let Some(discovered) = discovered {
                    self.server.sync(discovered).await?;
                } else {
                   {
                       use ::tracing::__macro_support::Callsite as _;
                       static CALLSITE: ::tracing::callsite::DefaultCallsite =
                           {
                               static META: ::tracing::Metadata<'static> =
                                   {
                                       ::tracing_core::metadata::Metadata::new("event src/api.rs:309",
                                           "native::api", ::tracing::Level::WARN, Some("src/api.rs"),
                                           Some(309u32), Some("native::api"),
                                           ::tracing_core::field::FieldSet::new(&["message"],
                                               ::tracing_core::callsite::Identifier(&CALLSITE)),
                                           ::tracing::metadata::Kind::EVENT)
                                   };
                               ::tracing::callsite::DefaultCallsite::new(&META)
                           };
                       let enabled =
                           ::tracing::Level::WARN <=
                                       ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                   ::tracing::Level::WARN <=
                                       ::tracing::level_filters::LevelFilter::current() &&
                               {
                                   let interest = CALLSITE.interest();
                                   !interest.is_never() &&
                                       ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                           interest)
                               };
                       if enabled {
                               (|value_set: ::tracing::field::ValueSet|
                                           {
                                               let meta = CALLSITE.metadata();
                                               ::tracing::Event::dispatch(meta, &value_set);
                                               ;
                                           })({
                                       #[allow(unused_imports)]
                                       use ::tracing::field::{debug, display, Value};
                                       let mut iter = CALLSITE.metadata().fields().iter();
                                       CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                           Some(&format_args!("{0:?} undiscovered!", &device_id) as
                                                                   &dyn Value))])
                                   });
                           } else { ; }
                   };
               }
            Ok(TransferProgress {
                    device_id: device_id.0,
                    status: TransferStatus::Starting,
                })
        }
        async fn start_upload(&self, device_id: DeviceId, tokens: Tokens,
            files: Vec<RecordArchive>) -> Result<TransferProgress> {
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                    {
                        static META: ::tracing::Metadata<'static> =
                            {
                                ::tracing_core::metadata::Metadata::new("event src/api.rs:324",
                                    "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                    Some(324u32), Some("native::api"),
                                    ::tracing_core::field::FieldSet::new(&["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                    ::tracing::metadata::Kind::EVENT)
                            };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                let enabled =
                    ::tracing::Level::INFO <=
                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                            ::tracing::Level::INFO <=
                                ::tracing::level_filters::LevelFilter::current() &&
                        {
                            let interest = CALLSITE.interest();
                            !interest.is_never() &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest)
                        };
                if enabled {
                        (|value_set: ::tracing::field::ValueSet|
                                    {
                                        let meta = CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        ;
                                    })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&format_args!("{0:?} start upload", &device_id) as
                                                            &dyn Value))])
                            });
                    } else { ; }
            };
            tokio::task::spawn({
                    let client =
                        query::portal::Client::new(&self.portal_base_url)?;
                    let authenticated = client.to_authenticated(tokens.into())?;
                    let publish_tx = self.publish_tx.clone();
                    let device_id = device_id.clone();
                    async move
                        {
                        for file in files.into_iter() {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                    {
                                        static META: ::tracing::Metadata<'static> =
                                            {
                                                ::tracing_core::metadata::Metadata::new("event src/api.rs:334",
                                                    "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                                    Some(334u32), Some("native::api"),
                                                    ::tracing_core::field::FieldSet::new(&["message"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                    ::tracing::metadata::Kind::EVENT)
                                            };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                let enabled =
                                    ::tracing::Level::INFO <=
                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                            ::tracing::Level::INFO <=
                                                ::tracing::level_filters::LevelFilter::current() &&
                                        {
                                            let interest = CALLSITE.interest();
                                            !interest.is_never() &&
                                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                    interest)
                                        };
                                if enabled {
                                        (|value_set: ::tracing::field::ValueSet|
                                                    {
                                                        let meta = CALLSITE.metadata();
                                                        ::tracing::Event::dispatch(meta, &value_set);
                                                        ;
                                                    })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&format_args!("{0:?} uploading", &file) as
                                                                            &dyn Value))])
                                            });
                                    } else { ; }
                            };
                            let res =
                                authenticated.upload_readings(&PathBuf::from(file.path)).await;
                            let status =
                                match res {
                                    Ok(mut stream) => {
                                        while let Some(Ok(bytes)) = stream.next().await {
                                            match publish_tx.send(DomainMessage::UploadProgress(TransferProgress {
                                                                device_id: device_id.clone().into(),
                                                                status: TransferStatus::Uploading(UploadProgress {
                                                                        bytes_uploaded: bytes.bytes_uploaded,
                                                                        total_bytes: bytes.total_bytes,
                                                                    }),
                                                            })).await {
                                                Ok(_) => {}
                                                Err(e) => {
                                                    use ::tracing::__macro_support::Callsite as _;
                                                    static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                                        {
                                                            static META: ::tracing::Metadata<'static> =
                                                                {
                                                                    ::tracing_core::metadata::Metadata::new("event src/api.rs:354",
                                                                        "native::api", ::tracing::Level::WARN, Some("src/api.rs"),
                                                                        Some(354u32), Some("native::api"),
                                                                        ::tracing_core::field::FieldSet::new(&["message"],
                                                                            ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                                        ::tracing::metadata::Kind::EVENT)
                                                                };
                                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                                        };
                                                    let enabled =
                                                        ::tracing::Level::WARN <=
                                                                    ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                                ::tracing::Level::WARN <=
                                                                    ::tracing::level_filters::LevelFilter::current() &&
                                                            {
                                                                let interest = CALLSITE.interest();
                                                                !interest.is_never() &&
                                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                                        interest)
                                                            };
                                                    if enabled {
                                                            (|value_set: ::tracing::field::ValueSet|
                                                                        {
                                                                            let meta = CALLSITE.metadata();
                                                                            ::tracing::Event::dispatch(meta, &value_set);
                                                                            ;
                                                                        })({
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = CALLSITE.metadata().fields().iter();
                                                                    CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                        Some(&format_args!("Publish failed: {0:?}", e) as
                                                                                                &dyn Value))])
                                                                });
                                                        } else { ; }
                                                }
                                            }
                                        }
                                        TransferStatus::Completed
                                    }
                                    Err(e) => {
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                                {
                                                    static META: ::tracing::Metadata<'static> =
                                                        {
                                                            ::tracing_core::metadata::Metadata::new("event src/api.rs:361",
                                                                "native::api", ::tracing::Level::WARN, Some("src/api.rs"),
                                                                Some(361u32), Some("native::api"),
                                                                ::tracing_core::field::FieldSet::new(&["message"],
                                                                    ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                                ::tracing::metadata::Kind::EVENT)
                                                        };
                                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                                };
                                            let enabled =
                                                ::tracing::Level::WARN <=
                                                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                        ::tracing::Level::WARN <=
                                                            ::tracing::level_filters::LevelFilter::current() &&
                                                    {
                                                        let interest = CALLSITE.interest();
                                                        !interest.is_never() &&
                                                            ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                                interest)
                                                    };
                                            if enabled {
                                                    (|value_set: ::tracing::field::ValueSet|
                                                                {
                                                                    let meta = CALLSITE.metadata();
                                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                                    ;
                                                                })({
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&format_args!("Upload failed: {0:?}", e) as
                                                                                        &dyn Value))])
                                                        });
                                                } else { ; }
                                        };
                                        TransferStatus::Failed
                                    }
                                };
                            publish_tx.send(DomainMessage::UploadProgress(TransferProgress {
                                                device_id: device_id.clone().into(),
                                                status,
                                            })).await.expect("Publish failed")
                        }
                    }
                });
            Ok(TransferProgress {
                    device_id: device_id.into(),
                    status: TransferStatus::Starting,
                })
        }
        async fn get_nearby_addr(&self, device_id: &DeviceId)
            -> Result<Option<String>> {
            let discovered = self.nearby.get_discovered(&device_id).await;
            Ok(discovered.map(|d|
                        {
                            d.http_addr.map(|o|
                                        {
                                            let res = ::alloc::fmt::format(format_args!("{0}", o));
                                            res
                                        }).expect("Expected HTTP url")
                        }))
        }
        async fn configure_wifi_transmission(&self, device_id: DeviceId,
            config: WifiTransmissionConfig) -> Result<()> {
            if let Some(addr) = self.get_nearby_addr(&device_id).await? {
                    let client = query::device::Client::new()?;
                    client.configure_wifi_transmission(&addr,
                                config.into()).await?;
                }
            Ok(())
        }
        async fn clear_calibration(&self, device_id: DeviceId, module: usize)
            -> Result<()> {
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                    {
                        static META: ::tracing::Metadata<'static> =
                            {
                                ::tracing_core::metadata::Metadata::new("event src/api.rs:409",
                                    "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                    Some(409u32), Some("native::api"),
                                    ::tracing_core::field::FieldSet::new(&["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                    ::tracing::metadata::Kind::EVENT)
                            };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                let enabled =
                    ::tracing::Level::INFO <=
                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                            ::tracing::Level::INFO <=
                                ::tracing::level_filters::LevelFilter::current() &&
                        {
                            let interest = CALLSITE.interest();
                            !interest.is_never() &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest)
                        };
                if enabled {
                        (|value_set: ::tracing::field::ValueSet|
                                    {
                                        let meta = CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        ;
                                    })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&format_args!("clear-calibration: {0:?} {1:?}",
                                                                    device_id, module) as &dyn Value))])
                            });
                    } else { ; }
            };
            if let Some(addr) = self.get_nearby_addr(&device_id).await? {
                    let client = query::device::Client::new()?;
                    client.clear_calibration(&addr, module).await?;
                }
            Ok(())
        }
        async fn calibrate(&self, device_id: DeviceId, module: usize,
            data: Vec<u8>) -> Result<()> {
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                    {
                        static META: ::tracing::Metadata<'static> =
                            {
                                ::tracing_core::metadata::Metadata::new("event src/api.rs:419",
                                    "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                    Some(419u32), Some("native::api"),
                                    ::tracing_core::field::FieldSet::new(&["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                    ::tracing::metadata::Kind::EVENT)
                            };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                let enabled =
                    ::tracing::Level::INFO <=
                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                            ::tracing::Level::INFO <=
                                ::tracing::level_filters::LevelFilter::current() &&
                        {
                            let interest = CALLSITE.interest();
                            !interest.is_never() &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest)
                        };
                if enabled {
                        (|value_set: ::tracing::field::ValueSet|
                                    {
                                        let meta = CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        ;
                                    })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&format_args!("calibrate: {0:?} {1:?} {2:?}",
                                                                    device_id, module, data) as &dyn Value))])
                            });
                    } else { ; }
            };
            if let Some(addr) = self.get_nearby_addr(&device_id).await? {
                    let client = query::device::Client::new()?;
                    client.calibrate(&addr, module, &data).await?;
                }
            Ok(())
        }
        async fn cache_firmware(&self, tokens: Option<Tokens>)
            -> Result<FirmwareDownloadStatus> {
            crate::firmware::cache_firmware(self.portal_base_url.clone(),
                    self.storage_path.clone(), self.publish_tx.clone(),
                    tokens).await
        }
        async fn upgrade_station(&self, device_id: DeviceId,
            firmware: LocalFirmware, swap: bool) -> Result<UpgradeProgress> {
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                    {
                        static META: ::tracing::Metadata<'static> =
                            {
                                ::tracing_core::metadata::Metadata::new("event src/api.rs:444",
                                    "native::api", ::tracing::Level::INFO, Some("src/api.rs"),
                                    Some(444u32), Some("native::api"),
                                    ::tracing_core::field::FieldSet::new(&["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                    ::tracing::metadata::Kind::EVENT)
                            };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                let enabled =
                    ::tracing::Level::INFO <=
                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                            ::tracing::Level::INFO <=
                                ::tracing::level_filters::LevelFilter::current() &&
                        {
                            let interest = CALLSITE.interest();
                            !interest.is_never() &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest)
                        };
                if enabled {
                        (|value_set: ::tracing::field::ValueSet|
                                    {
                                        let meta = CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        ;
                                    })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&format_args!("upgrade-station: {0:?} to {1:?}",
                                                                    device_id, firmware) as &dyn Value))])
                            });
                    } else { ; }
            };
            match self.get_nearby_addr(&device_id).await? {
                Some(addr) => {
                    let nearby = self.nearby.clone();
                    crate::firmware::upgrade(nearby, self.publish_tx.clone(),
                            self.storage_path.clone(), device_id, firmware, swap,
                            addr).await
                }
                None => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/api.rs:461",
                                            "native::api", ::tracing::Level::WARN, Some("src/api.rs"),
                                            Some(461u32), Some("native::api"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::WARN <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::WARN <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("No nearby for station!") as
                                                                    &dyn Value))])
                                    });
                            } else { ; }
                    };
                    Ok(UpgradeProgress {
                            device_id: device_id.0.clone(),
                            firmware_id: firmware.id,
                            status: UpgradeStatus::Failed,
                        })
                }
            }
        }
    }
    pub fn get_my_stations() -> Result<Vec<StationConfig>> {
        Ok(with_runtime(|rt, sdk| rt.block_on(sdk.get_my_stations()))?)
    }
    pub fn authenticate_portal(email: String, password: String)
        -> Result<Authenticated> {
        Ok(with_runtime(|rt, sdk|
                        { rt.block_on(sdk.authenticate_portal(email, password)) })?)
    }
    pub fn add_or_update_station_in_portal(tokens: Tokens,
        station: AddOrUpdatePortalStation) -> Result<Option<u32>> {
        Ok(with_runtime(|rt, sdk|
                        {
                            rt.block_on(sdk.add_or_update_station_in_portal(tokens,
                                    station))
                        })?)
    }
    pub fn configure_wifi_transmission(device_id: String,
        config: WifiTransmissionConfig) -> Result<()> {
        Ok(with_runtime(|rt, sdk|
                        {
                            rt.block_on(sdk.configure_wifi_transmission(DeviceId(device_id.clone()),
                                    config))
                        })?)
    }
    pub fn clear_calibration(device_id: String, module: usize) -> Result<()> {
        Ok(with_runtime(|rt, sdk|
                        {
                            rt.block_on(sdk.clear_calibration(DeviceId(device_id.clone()),
                                    module))
                        })?)
    }
    pub fn calibrate(device_id: String, module: usize, data: Vec<u8>)
        -> Result<()> {
        Ok(with_runtime(|rt, sdk|
                        {
                            rt.block_on(sdk.calibrate(DeviceId(device_id.clone()),
                                    module, data))
                        })?)
    }
    pub fn validate_tokens(tokens: Tokens) -> Result<Authenticated> {
        Ok(with_runtime(|rt, sdk|
                        { rt.block_on(sdk.validate_tokens(tokens)) })?)
    }
    pub fn start_download(device_id: String) -> Result<TransferProgress> {
        Ok(with_runtime(|rt, sdk|
                        {
                            rt.block_on(sdk.start_download(DeviceId(device_id.clone())))
                        })?)
    }
    pub fn start_upload(device_id: String, tokens: Tokens,
        files: Vec<RecordArchive>) -> Result<TransferProgress> {
        Ok(with_runtime(|rt, sdk|
                        {
                            rt.block_on(sdk.start_upload(DeviceId(device_id.clone()),
                                    tokens, files))
                        })?)
    }
    pub fn cache_firmware(tokens: Option<Tokens>)
        -> Result<FirmwareDownloadStatus> {
        Ok(with_runtime(|rt, sdk|
                        { rt.block_on(sdk.cache_firmware(tokens)) })?)
    }
    pub fn upgrade_station(device_id: String, firmware: LocalFirmware,
        swap: bool) -> Result<UpgradeProgress> {
        Ok(with_runtime(|rt, sdk|
                        {
                            rt.block_on(sdk.upgrade_station(DeviceId(device_id.clone()),
                                    firmware, swap))
                        })?)
    }
    fn start_runtime() -> Result<Runtime> {
        let rt =
            tokio::runtime::Builder::new_multi_thread().worker_threads(4).enable_all().thread_name("fieldkit-client").build()?;
        Ok(rt)
    }
    fn with_runtime<R>(cb: impl FnOnce(&Runtime, &mut Sdk) -> Result<R>)
        -> Result<R> {
        let mut sdk_guard = SDK.lock().expect("Get sdk");
        let sdk = sdk_guard.as_mut().expect("Sdk present");
        let mut rt_guard = RUNTIME.lock().expect("Get runtime");
        let rt = rt_guard.as_mut().expect("Runtime present");
        let _guard = rt.enter();
        cb(rt, sdk)
    }
    #[allow(dead_code)]
    fn with_sdk<R>(cb: impl FnOnce(&mut Sdk) -> Result<R>) -> Result<R> {
        with_runtime(|_rt, sdk| cb(sdk))
    }
    pub fn rust_release_mode() -> bool { false }
    /// Wrapper so that we can implement required Write and MakeWriter traits.
    struct LogSink {
        sink: StreamSink<String>,
    }
    /// Write log lines to our Flutter's sink.
    impl<'a> Write for &'a LogSink {
        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
            let line = String::from_utf8_lossy(buf).to_string();
            self.sink.add(line);
            Ok(buf.len())
        }
        fn flush(&mut self) -> std::io::Result<()> { Ok(()) }
    }
    impl<'a> MakeWriter<'a> for LogSink {
        type Writer = &'a LogSink;
        fn make_writer(&'a self) -> Self::Writer { self }
    }
    pub fn create_log_sink(sink: StreamSink<String>) -> Result<()> {
        fn get_rust_log() -> String {
            let mut original =
                std::env::var("RUST_LOG").unwrap_or_else(|_| "debug".into());
            for logger in
                ["hyper=", "reqwest=", "rusqlite_migration=", "rustls=",
                        "h2="] {
                if !original.contains(logger) {
                        original.push_str(&{
                                    let res =
                                        ::alloc::fmt::format(format_args!(",{0}info", logger));
                                    res
                                });
                    }
            }
            original
        }
        if let Err(err) =
                    tracing_subscriber::fmt().with_max_level(tracing::Level::TRACE).with_env_filter(EnvFilter::new(get_rust_log())).with_writer(LogSink {
                                sink,
                            }).try_init() {
                return ::anyhow::__private::Err(::anyhow::Error::msg({
                                let res = ::alloc::fmt::format(format_args!("{0}", err));
                                res
                            }));
            }
        Ok(())
    }
    pub struct WifiTransmissionConfig {
        pub tokens: Option<Tokens>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for WifiTransmissionConfig {
        #[inline]
        fn clone(&self) -> WifiTransmissionConfig {
            WifiTransmissionConfig {
                tokens: ::core::clone::Clone::clone(&self.tokens),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for WifiTransmissionConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f,
                "WifiTransmissionConfig", "tokens", &&self.tokens)
        }
    }
    impl Into<device::ConfigureWifiTransmission> for WifiTransmissionConfig {
        fn into(self) -> device::ConfigureWifiTransmission {
            self.tokens.map(|t|
                        device::ConfigureWifiTransmission {
                            enabled: true,
                            token: Some(t.transmission.token.clone()),
                            url: Some(t.transmission.url.clone()),
                        }).unwrap_or(device::ConfigureWifiTransmission::default())
        }
    }
    pub struct AddOrUpdatePortalStation {
        pub name: String,
        pub device_id: String,
        pub location_name: String,
        pub status_pb: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AddOrUpdatePortalStation {
        #[inline]
        fn clone(&self) -> AddOrUpdatePortalStation {
            AddOrUpdatePortalStation {
                name: ::core::clone::Clone::clone(&self.name),
                device_id: ::core::clone::Clone::clone(&self.device_id),
                location_name: ::core::clone::Clone::clone(&self.location_name),
                status_pb: ::core::clone::Clone::clone(&self.status_pb),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AddOrUpdatePortalStation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(f,
                "AddOrUpdatePortalStation", "name", &self.name, "device_id",
                &self.device_id, "location_name", &self.location_name,
                "status_pb", &&self.status_pb)
        }
    }
    impl Into<query::portal::AddStation> for AddOrUpdatePortalStation {
        fn into(self) -> query::portal::AddStation {
            query::portal::AddStation {
                name: self.name,
                device_id: self.device_id,
                location_name: self.location_name,
                status_pb: self.status_pb,
            }
        }
    }
    pub struct Tokens {
        pub token: String,
        pub transmission: TransmissionToken,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Tokens {
        #[inline]
        fn clone(&self) -> Tokens {
            Tokens {
                token: ::core::clone::Clone::clone(&self.token),
                transmission: ::core::clone::Clone::clone(&self.transmission),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Tokens {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f, "Tokens",
                "token", &self.token, "transmission", &&self.transmission)
        }
    }
    impl Tokens {
        fn from(tokens: query::portal::Tokens,
            transmission: query::portal::TransmissionToken) -> Self {
            Self {
                token: tokens.token,
                transmission: TransmissionToken {
                    token: transmission.token,
                    url: transmission.url,
                },
            }
        }
        fn decoded(&self) -> Result<DecodedToken, PortalError> {
            DecodedToken::decode(&self.token)
        }
        fn refresh_token(&self) -> Result<String> {
            Ok(self.decoded()?.refresh_token)
        }
    }
    impl Into<query::portal::Tokens> for Tokens {
        fn into(self) -> query::portal::Tokens {
            query::portal::Tokens { token: self.token }
        }
    }
    pub struct TransmissionToken {
        pub token: String,
        pub url: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TransmissionToken {
        #[inline]
        fn clone(&self) -> TransmissionToken {
            TransmissionToken {
                token: ::core::clone::Clone::clone(&self.token),
                url: ::core::clone::Clone::clone(&self.url),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TransmissionToken {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f,
                "TransmissionToken", "token", &self.token, "url", &&self.url)
        }
    }
    pub struct Authenticated {
        pub email: String,
        pub name: String,
        pub tokens: Tokens,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Authenticated {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(f,
                "Authenticated", "email", &self.email, "name", &self.name,
                "tokens", &&self.tokens)
        }
    }
    pub struct DownloadProgress {
        pub started: u64,
        pub completed: f32,
        pub total: usize,
        pub received: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DownloadProgress {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(f,
                "DownloadProgress", "started", &self.started, "completed",
                &self.completed, "total", &self.total, "received",
                &&self.received)
        }
    }
    pub struct UploadProgress {
        pub bytes_uploaded: u64,
        pub total_bytes: u64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UploadProgress {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f,
                "UploadProgress", "bytes_uploaded", &self.bytes_uploaded,
                "total_bytes", &&self.total_bytes)
        }
    }
    #[allow(dead_code)]
    pub enum TransferStatus {
        Starting,
        Downloading(DownloadProgress),
        Uploading(UploadProgress),
        Processing,
        Completed,
        Failed,
    }
    #[automatically_derived]
    #[allow(dead_code)]
    impl ::core::fmt::Debug for TransferStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TransferStatus::Starting =>
                    ::core::fmt::Formatter::write_str(f, "Starting"),
                TransferStatus::Downloading(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Downloading", &__self_0),
                TransferStatus::Uploading(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Uploading", &__self_0),
                TransferStatus::Processing =>
                    ::core::fmt::Formatter::write_str(f, "Processing"),
                TransferStatus::Completed =>
                    ::core::fmt::Formatter::write_str(f, "Completed"),
                TransferStatus::Failed =>
                    ::core::fmt::Formatter::write_str(f, "Failed"),
            }
        }
    }
    #[allow(dead_code)]
    pub enum FirmwareDownloadStatus {
        Checking,
        Downloading(DownloadProgress),
        Offline,
        Completed,
        Failed,
    }
    #[automatically_derived]
    #[allow(dead_code)]
    impl ::core::fmt::Debug for FirmwareDownloadStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                FirmwareDownloadStatus::Checking =>
                    ::core::fmt::Formatter::write_str(f, "Checking"),
                FirmwareDownloadStatus::Downloading(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Downloading", &__self_0),
                FirmwareDownloadStatus::Offline =>
                    ::core::fmt::Formatter::write_str(f, "Offline"),
                FirmwareDownloadStatus::Completed =>
                    ::core::fmt::Formatter::write_str(f, "Completed"),
                FirmwareDownloadStatus::Failed =>
                    ::core::fmt::Formatter::write_str(f, "Failed"),
            }
        }
    }
    #[allow(dead_code)]
    pub enum UpgradeStatus {
        Starting,
        Uploading(UploadProgress),
        Restarting,
        Completed,
        Failed,
    }
    #[automatically_derived]
    #[allow(dead_code)]
    impl ::core::fmt::Debug for UpgradeStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UpgradeStatus::Starting =>
                    ::core::fmt::Formatter::write_str(f, "Starting"),
                UpgradeStatus::Uploading(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Uploading", &__self_0),
                UpgradeStatus::Restarting =>
                    ::core::fmt::Formatter::write_str(f, "Restarting"),
                UpgradeStatus::Completed =>
                    ::core::fmt::Formatter::write_str(f, "Completed"),
                UpgradeStatus::Failed =>
                    ::core::fmt::Formatter::write_str(f, "Failed"),
            }
        }
    }
    pub struct UpgradeProgress {
        pub device_id: String,
        pub firmware_id: i64,
        pub status: UpgradeStatus,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UpgradeProgress {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(f,
                "UpgradeProgress", "device_id", &self.device_id,
                "firmware_id", &self.firmware_id, "status", &&self.status)
        }
    }
    pub struct TransferProgress {
        pub device_id: String,
        pub status: TransferStatus,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TransferProgress {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f,
                "TransferProgress", "device_id", &self.device_id, "status",
                &&self.status)
        }
    }
    pub struct RecordArchive {
        pub device_id: String,
        pub path: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RecordArchive {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f,
                "RecordArchive", "device_id", &self.device_id, "path",
                &&self.path)
        }
    }
    pub enum DomainMessage {
        PreAccount,
        NearbyStations(Vec<NearbyStation>),
        StationRefreshed(StationConfig, Option<EphemeralConfig>, String),
        UploadProgress(TransferProgress),
        DownloadProgress(TransferProgress),
        FirmwareDownloadStatus(FirmwareDownloadStatus),
        UpgradeProgress(UpgradeProgress),
        AvailableFirmware(Vec<LocalFirmware>),
        RecordArchives(Vec<RecordArchive>),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DomainMessage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                DomainMessage::PreAccount =>
                    ::core::fmt::Formatter::write_str(f, "PreAccount"),
                DomainMessage::NearbyStations(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "NearbyStations", &__self_0),
                DomainMessage::StationRefreshed(__self_0, __self_1, __self_2)
                    =>
                    ::core::fmt::Formatter::debug_tuple_field3_finish(f,
                        "StationRefreshed", __self_0, __self_1, &__self_2),
                DomainMessage::UploadProgress(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "UploadProgress", &__self_0),
                DomainMessage::DownloadProgress(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "DownloadProgress", &__self_0),
                DomainMessage::FirmwareDownloadStatus(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "FirmwareDownloadStatus", &__self_0),
                DomainMessage::UpgradeProgress(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "UpgradeProgress", &__self_0),
                DomainMessage::AvailableFirmware(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "AvailableFirmware", &__self_0),
                DomainMessage::RecordArchives(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "RecordArchives", &__self_0),
            }
        }
    }
    pub struct LocalFirmware {
        pub id: i64,
        pub label: String,
        pub time: i64,
        pub module: String,
        pub profile: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LocalFirmware {
        #[inline]
        fn clone(&self) -> LocalFirmware {
            LocalFirmware {
                id: ::core::clone::Clone::clone(&self.id),
                label: ::core::clone::Clone::clone(&self.label),
                time: ::core::clone::Clone::clone(&self.time),
                module: ::core::clone::Clone::clone(&self.module),
                profile: ::core::clone::Clone::clone(&self.profile),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LocalFirmware {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(f,
                "LocalFirmware", "id", &self.id, "label", &self.label, "time",
                &self.time, "module", &self.module, "profile", &&self.profile)
        }
    }
    pub struct StreamInfo {
        pub size: u64,
        pub records: u64,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StreamInfo {
        #[inline]
        fn clone(&self) -> StreamInfo {
            StreamInfo {
                size: ::core::clone::Clone::clone(&self.size),
                records: ::core::clone::Clone::clone(&self.records),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StreamInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f,
                "StreamInfo", "size", &self.size, "records", &&self.records)
        }
    }
    pub struct BatteryInfo {
        pub percentage: f32,
        pub voltage: f32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BatteryInfo {
        #[inline]
        fn clone(&self) -> BatteryInfo {
            BatteryInfo {
                percentage: ::core::clone::Clone::clone(&self.percentage),
                voltage: ::core::clone::Clone::clone(&self.voltage),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BatteryInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f,
                "BatteryInfo", "percentage", &self.percentage, "voltage",
                &&self.voltage)
        }
    }
    pub struct SolarInfo {
        pub voltage: f32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SolarInfo {
        #[inline]
        fn clone(&self) -> SolarInfo {
            SolarInfo { voltage: ::core::clone::Clone::clone(&self.voltage) }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SolarInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f, "SolarInfo",
                "voltage", &&self.voltage)
        }
    }
    pub struct StationConfig {
        pub device_id: String,
        pub name: String,
        pub firmware: FirmwareInfo,
        pub last_seen: DateTime<Utc>,
        pub meta: StreamInfo,
        pub data: StreamInfo,
        pub battery: BatteryInfo,
        pub solar: SolarInfo,
        pub modules: Vec<ModuleConfig>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StationConfig {
        #[inline]
        fn clone(&self) -> StationConfig {
            StationConfig {
                device_id: ::core::clone::Clone::clone(&self.device_id),
                name: ::core::clone::Clone::clone(&self.name),
                firmware: ::core::clone::Clone::clone(&self.firmware),
                last_seen: ::core::clone::Clone::clone(&self.last_seen),
                meta: ::core::clone::Clone::clone(&self.meta),
                data: ::core::clone::Clone::clone(&self.data),
                battery: ::core::clone::Clone::clone(&self.battery),
                solar: ::core::clone::Clone::clone(&self.solar),
                modules: ::core::clone::Clone::clone(&self.modules),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StationConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ =
                &["device_id", "name", "firmware", "last_seen", "meta",
                            "data", "battery", "solar", "modules"];
            let values: &[&dyn ::core::fmt::Debug] =
                &[&self.device_id, &self.name, &self.firmware,
                            &self.last_seen, &self.meta, &self.data, &self.battery,
                            &self.solar, &&self.modules];
            ::core::fmt::Formatter::debug_struct_fields_finish(f,
                "StationConfig", names, values)
        }
    }
    pub struct CapabilitiesInfo {
        pub udp: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CapabilitiesInfo {
        #[inline]
        fn clone(&self) -> CapabilitiesInfo {
            CapabilitiesInfo { udp: ::core::clone::Clone::clone(&self.udp) }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CapabilitiesInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f,
                "CapabilitiesInfo", "udp", &&self.udp)
        }
    }
    pub struct FirmwareInfo {
        pub label: String,
        pub time: i64,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FirmwareInfo {
        #[inline]
        fn clone(&self) -> FirmwareInfo {
            FirmwareInfo {
                label: ::core::clone::Clone::clone(&self.label),
                time: ::core::clone::Clone::clone(&self.time),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FirmwareInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f,
                "FirmwareInfo", "label", &self.label, "time", &&self.time)
        }
    }
    pub struct ModuleConfig {
        pub position: u32,
        pub module_id: String,
        pub key: String,
        pub sensors: Vec<SensorConfig>,
        pub configuration: Option<Vec<u8>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ModuleConfig {
        #[inline]
        fn clone(&self) -> ModuleConfig {
            ModuleConfig {
                position: ::core::clone::Clone::clone(&self.position),
                module_id: ::core::clone::Clone::clone(&self.module_id),
                key: ::core::clone::Clone::clone(&self.key),
                sensors: ::core::clone::Clone::clone(&self.sensors),
                configuration: ::core::clone::Clone::clone(&self.configuration),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ModuleConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(f,
                "ModuleConfig", "position", &self.position, "module_id",
                &self.module_id, "key", &self.key, "sensors", &self.sensors,
                "configuration", &&self.configuration)
        }
    }
    pub struct SensorConfig {
        pub number: u32,
        pub key: String,
        pub full_key: String,
        pub calibrated_uom: String,
        pub uncalibrated_uom: String,
        pub value: Option<SensorValue>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SensorConfig {
        #[inline]
        fn clone(&self) -> SensorConfig {
            SensorConfig {
                number: ::core::clone::Clone::clone(&self.number),
                key: ::core::clone::Clone::clone(&self.key),
                full_key: ::core::clone::Clone::clone(&self.full_key),
                calibrated_uom: ::core::clone::Clone::clone(&self.calibrated_uom),
                uncalibrated_uom: ::core::clone::Clone::clone(&self.uncalibrated_uom),
                value: ::core::clone::Clone::clone(&self.value),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SensorConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ =
                &["number", "key", "full_key", "calibrated_uom",
                            "uncalibrated_uom", "value"];
            let values: &[&dyn ::core::fmt::Debug] =
                &[&self.number, &self.key, &self.full_key,
                            &self.calibrated_uom, &self.uncalibrated_uom, &&self.value];
            ::core::fmt::Formatter::debug_struct_fields_finish(f,
                "SensorConfig", names, values)
        }
    }
    pub struct SensorValue {
        pub time: DateTime<Utc>,
        pub value: f32,
        pub uncalibrated: f32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SensorValue {
        #[inline]
        fn clone(&self) -> SensorValue {
            SensorValue {
                time: ::core::clone::Clone::clone(&self.time),
                value: ::core::clone::Clone::clone(&self.value),
                uncalibrated: ::core::clone::Clone::clone(&self.uncalibrated),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SensorValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(f,
                "SensorValue", "time", &self.time, "value", &self.value,
                "uncalibrated", &&self.uncalibrated)
        }
    }
    pub struct NearbyStation {
        pub device_id: String,
        pub busy: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NearbyStation {
        #[inline]
        fn clone(&self) -> NearbyStation {
            NearbyStation {
                device_id: ::core::clone::Clone::clone(&self.device_id),
                busy: ::core::clone::Clone::clone(&self.busy),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NearbyStation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f,
                "NearbyStation", "device_id", &self.device_id, "busy",
                &&self.busy)
        }
    }
    pub struct EphemeralConfig {
        pub transmission: Option<TransmissionConfig>,
        pub networks: Vec<NetworkConfig>,
        pub capabilities: DeviceCapabilities,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EphemeralConfig {
        #[inline]
        fn clone(&self) -> EphemeralConfig {
            EphemeralConfig {
                transmission: ::core::clone::Clone::clone(&self.transmission),
                networks: ::core::clone::Clone::clone(&self.networks),
                capabilities: ::core::clone::Clone::clone(&self.capabilities),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EphemeralConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(f,
                "EphemeralConfig", "transmission", &self.transmission,
                "networks", &self.networks, "capabilities",
                &&self.capabilities)
        }
    }
    pub struct DeviceCapabilities {
        pub udp: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DeviceCapabilities {
        #[inline]
        fn clone(&self) -> DeviceCapabilities {
            DeviceCapabilities { udp: ::core::clone::Clone::clone(&self.udp) }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DeviceCapabilities {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f,
                "DeviceCapabilities", "udp", &&self.udp)
        }
    }
    impl TryInto<EphemeralConfig> for HttpReply {
        type Error = SdkMappingError;
        fn try_into(self)
            -> std::result::Result<EphemeralConfig, Self::Error> {
            let transmission =
                self.transmission.map(|t|
                                t.wifi).flatten().map(|_|
                        TransmissionConfig { enabled: true });
            let capabilities =
                DeviceCapabilities {
                    udp: self.network_settings.map(|s|
                                s.supports_udp).unwrap_or(false),
                };
            Ok(EphemeralConfig {
                    transmission,
                    networks: Vec::new(),
                    capabilities,
                })
        }
    }
    pub struct NetworkConfig {
        pub ssid: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NetworkConfig {
        #[inline]
        fn clone(&self) -> NetworkConfig {
            NetworkConfig { ssid: ::core::clone::Clone::clone(&self.ssid) }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NetworkConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f,
                "NetworkConfig", "ssid", &&self.ssid)
        }
    }
    pub struct TransmissionConfig {
        pub enabled: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TransmissionConfig {
        #[inline]
        fn clone(&self) -> TransmissionConfig {
            TransmissionConfig {
                enabled: ::core::clone::Clone::clone(&self.enabled),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TransmissionConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f,
                "TransmissionConfig", "enabled", &&self.enabled)
        }
    }
    pub struct StationAndConnection {
        station: store::Station,
        #[allow(dead_code)]
        connection: Option<Connection>,
    }
    impl TryInto<StationConfig> for StationAndConnection {
        type Error = SdkMappingError;
        fn try_into(self) -> std::result::Result<StationConfig, Self::Error> {
            let station = self.station;
            Ok(StationConfig {
                    device_id: station.device_id.0.to_owned(),
                    name: station.name,
                    last_seen: station.last_seen,
                    firmware: FirmwareInfo {
                        label: station.firmware.label,
                        time: station.firmware.time,
                    },
                    meta: StreamInfo {
                        size: station.meta.size,
                        records: station.meta.records,
                    },
                    data: StreamInfo {
                        size: station.data.size,
                        records: station.data.records,
                    },
                    battery: BatteryInfo {
                        percentage: station.battery.percentage,
                        voltage: station.battery.voltage,
                    },
                    solar: SolarInfo { voltage: station.solar.voltage },
                    modules: station.modules.into_iter().map(|module|
                                ModuleConfig {
                                    position: module.position,
                                    module_id: module.hardware_id,
                                    key: module.key.clone(),
                                    configuration: module.configuration,
                                    sensors: module.sensors.into_iter().map(|sensor|
                                                SensorConfig {
                                                    number: sensor.number,
                                                    full_key: {
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}.{1}", &module.key,
                                                                    &sensor.key));
                                                        res
                                                    },
                                                    key: sensor.key,
                                                    calibrated_uom: sensor.calibrated_uom,
                                                    uncalibrated_uom: sensor.uncalibrated_uom,
                                                    value: sensor.value.map(|v|
                                                            SensorValue {
                                                                time: v.time,
                                                                value: v.value,
                                                                uncalibrated: v.uncalibrated,
                                                            }),
                                                }).collect(),
                                }).collect(),
                })
        }
    }
    pub enum SdkMappingError {}
    #[allow(unused_qualifications)]
    impl std::error::Error for SdkMappingError { }
    #[allow(unused_qualifications)]
    impl std::fmt::Display for SdkMappingError {
        fn fmt(&self, __formatter: &mut std::fmt::Formatter)
            -> std::fmt::Result {

            #[allow(unused_variables, deprecated, clippy ::
            used_underscore_binding)]
            match *self { }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SdkMappingError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            unsafe { ::core::intrinsics::unreachable() }
        }
    }
}
mod bridge_generated {
    #![allow(non_camel_case_types, unused, clippy :: redundant_closure, clippy
    :: useless_conversion, clippy :: unit_arg, clippy :: double_parens,
    non_snake_case, clippy :: too_many_arguments)]
    use crate::api::*;
    use core::panic::UnwindSafe;
    use flutter_rust_bridge::rust2dart::IntoIntoDart;
    use flutter_rust_bridge::*;
    use std::ffi::c_void;
    use std::sync::Arc;
    use crate::logging::api::AddOrUpdatePortalStation;
    use crate::logging::api::Authenticated;
    use crate::logging::api::BatteryInfo;
    use crate::logging::api::DeviceCapabilities;
    use crate::logging::api::DomainMessage;
    use crate::logging::api::DownloadProgress;
    use crate::logging::api::EphemeralConfig;
    use crate::logging::api::FirmwareDownloadStatus;
    use crate::logging::api::FirmwareInfo;
    use crate::logging::api::LocalFirmware;
    use crate::logging::api::ModuleConfig;
    use crate::logging::api::NearbyStation;
    use crate::logging::api::NetworkConfig;
    use crate::logging::api::RecordArchive;
    use crate::logging::api::SensorConfig;
    use crate::logging::api::SensorValue;
    use crate::logging::api::SolarInfo;
    use crate::logging::api::StationConfig;
    use crate::logging::api::StreamInfo;
    use crate::logging::api::Tokens;
    use crate::logging::api::TransferProgress;
    use crate::logging::api::TransferStatus;
    use crate::logging::api::TransmissionConfig;
    use crate::logging::api::TransmissionToken;
    use crate::logging::api::UpgradeProgress;
    use crate::logging::api::UpgradeStatus;
    use crate::logging::api::UploadProgress;
    use crate::logging::api::WifiTransmissionConfig;
    fn wire_start_native_impl(port_: MessagePort,
        storage_path: impl Wire2Api<String> + UnwindSafe,
        portal_base_url: impl Wire2Api<String> + UnwindSafe) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (),
            _>(WrapInfo {
                debug_name: "start_native",
                port: Some(port_),
                mode: FfiCallMode::Stream,
            },
            move ||
                {
                    let api_storage_path = storage_path.wire2api();
                    let api_portal_base_url = portal_base_url.wire2api();
                    move |task_callback|
                        {
                            start_native(api_storage_path, api_portal_base_url,
                                task_callback.stream_sink::<_, DomainMessage>())
                        }
                })
    }
    fn wire_get_my_stations_impl(port_: MessagePort) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<StationConfig>,
            _>(WrapInfo {
                debug_name: "get_my_stations",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            }, move || move |task_callback| get_my_stations())
    }
    fn wire_authenticate_portal_impl(port_: MessagePort,
        email: impl Wire2Api<String> + UnwindSafe,
        password: impl Wire2Api<String> + UnwindSafe) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Authenticated,
            _>(WrapInfo {
                debug_name: "authenticate_portal",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move ||
                {
                    let api_email = email.wire2api();
                    let api_password = password.wire2api();
                    move |task_callback|
                        authenticate_portal(api_email, api_password)
                })
    }
    fn wire_add_or_update_station_in_portal_impl(port_: MessagePort,
        tokens: impl Wire2Api<Tokens> + UnwindSafe,
        station: impl Wire2Api<AddOrUpdatePortalStation> + UnwindSafe) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Option<u32>,
            _>(WrapInfo {
                debug_name: "add_or_update_station_in_portal",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move ||
                {
                    let api_tokens = tokens.wire2api();
                    let api_station = station.wire2api();
                    move |task_callback|
                        add_or_update_station_in_portal(api_tokens, api_station)
                })
    }
    fn wire_configure_wifi_transmission_impl(port_: MessagePort,
        device_id: impl Wire2Api<String> + UnwindSafe,
        config: impl Wire2Api<WifiTransmissionConfig> + UnwindSafe) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (),
            _>(WrapInfo {
                debug_name: "configure_wifi_transmission",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move ||
                {
                    let api_device_id = device_id.wire2api();
                    let api_config = config.wire2api();
                    move |task_callback|
                        configure_wifi_transmission(api_device_id, api_config)
                })
    }
    fn wire_clear_calibration_impl(port_: MessagePort,
        device_id: impl Wire2Api<String> + UnwindSafe,
        module: impl Wire2Api<usize> + UnwindSafe) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (),
            _>(WrapInfo {
                debug_name: "clear_calibration",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move ||
                {
                    let api_device_id = device_id.wire2api();
                    let api_module = module.wire2api();
                    move |task_callback|
                        clear_calibration(api_device_id, api_module)
                })
    }
    fn wire_calibrate_impl(port_: MessagePort,
        device_id: impl Wire2Api<String> + UnwindSafe,
        module: impl Wire2Api<usize> + UnwindSafe,
        data: impl Wire2Api<Vec<u8>> + UnwindSafe) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (),
            _>(WrapInfo {
                debug_name: "calibrate",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move ||
                {
                    let api_device_id = device_id.wire2api();
                    let api_module = module.wire2api();
                    let api_data = data.wire2api();
                    move |task_callback|
                        calibrate(api_device_id, api_module, api_data)
                })
    }
    fn wire_validate_tokens_impl(port_: MessagePort,
        tokens: impl Wire2Api<Tokens> + UnwindSafe) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Authenticated,
            _>(WrapInfo {
                debug_name: "validate_tokens",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move ||
                {
                    let api_tokens = tokens.wire2api();
                    move |task_callback| validate_tokens(api_tokens)
                })
    }
    fn wire_start_download_impl(port_: MessagePort,
        device_id: impl Wire2Api<String> + UnwindSafe) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, TransferProgress,
            _>(WrapInfo {
                debug_name: "start_download",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move ||
                {
                    let api_device_id = device_id.wire2api();
                    move |task_callback| start_download(api_device_id)
                })
    }
    fn wire_start_upload_impl(port_: MessagePort,
        device_id: impl Wire2Api<String> + UnwindSafe,
        tokens: impl Wire2Api<Tokens> + UnwindSafe,
        files: impl Wire2Api<Vec<RecordArchive>> + UnwindSafe) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, TransferProgress,
            _>(WrapInfo {
                debug_name: "start_upload",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move ||
                {
                    let api_device_id = device_id.wire2api();
                    let api_tokens = tokens.wire2api();
                    let api_files = files.wire2api();
                    move |task_callback|
                        start_upload(api_device_id, api_tokens, api_files)
                })
    }
    fn wire_cache_firmware_impl(port_: MessagePort,
        tokens: impl Wire2Api<Option<Tokens>> + UnwindSafe) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, FirmwareDownloadStatus,
            _>(WrapInfo {
                debug_name: "cache_firmware",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move ||
                {
                    let api_tokens = tokens.wire2api();
                    move |task_callback| cache_firmware(api_tokens)
                })
    }
    fn wire_upgrade_station_impl(port_: MessagePort,
        device_id: impl Wire2Api<String> + UnwindSafe,
        firmware: impl Wire2Api<LocalFirmware> + UnwindSafe,
        swap: impl Wire2Api<bool> + UnwindSafe) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, UpgradeProgress,
            _>(WrapInfo {
                debug_name: "upgrade_station",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move ||
                {
                    let api_device_id = device_id.wire2api();
                    let api_firmware = firmware.wire2api();
                    let api_swap = swap.wire2api();
                    move |task_callback|
                        upgrade_station(api_device_id, api_firmware, api_swap)
                })
    }
    fn wire_rust_release_mode_impl(port_: MessagePort) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool,
            _>(WrapInfo {
                debug_name: "rust_release_mode",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move ||
                move |task_callback| Result::<_, ()>::Ok(rust_release_mode()))
    }
    fn wire_create_log_sink_impl(port_: MessagePort) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (),
            _>(WrapInfo {
                debug_name: "create_log_sink",
                port: Some(port_),
                mode: FfiCallMode::Stream,
            },
            move ||
                move |task_callback|
                    create_log_sink(task_callback.stream_sink::<_, String>()))
    }
    pub trait Wire2Api<T> {
        fn wire2api(self)
        -> T;
    }
    impl<T, S> Wire2Api<Option<T>> for *mut S where *mut S: Wire2Api<T> {
        fn wire2api(self) -> Option<T> {
            (!self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<bool> for bool {
        fn wire2api(self) -> bool { self }
    }
    impl Wire2Api<i64> for i64 {
        fn wire2api(self) -> i64 { self }
    }
    impl Wire2Api<u8> for u8 {
        fn wire2api(self) -> u8 { self }
    }
    impl Wire2Api<usize> for usize {
        fn wire2api(self) -> usize { self }
    }
    impl support::IntoDart for Authenticated {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.email.into_into_dart().into_dart(),
                                self.name.into_into_dart().into_dart(),
                                self.tokens.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for Authenticated {}
    impl rust2dart::IntoIntoDart<Authenticated> for Authenticated {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for BatteryInfo {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.percentage.into_into_dart().into_dart(),
                                self.voltage.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for BatteryInfo {}
    impl rust2dart::IntoIntoDart<BatteryInfo> for BatteryInfo {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for DeviceCapabilities {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.udp.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for DeviceCapabilities {}
    impl rust2dart::IntoIntoDart<DeviceCapabilities> for DeviceCapabilities {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for DomainMessage {
        fn into_dart(self) -> support::DartAbi {
            match self {
                    Self::PreAccount =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.into_dart()])),
                    Self::NearbyStations(field0) => {
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([1.into_dart(),
                                        field0.into_into_dart().into_dart()]))
                    }
                    Self::StationRefreshed(field0, field1, field2) =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([2.into_dart(),
                                        field0.into_into_dart().into_dart(), field1.into_dart(),
                                        field2.into_into_dart().into_dart()])),
                    Self::UploadProgress(field0) => {
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([3.into_dart(),
                                        field0.into_into_dart().into_dart()]))
                    }
                    Self::DownloadProgress(field0) => {
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([4.into_dart(),
                                        field0.into_into_dart().into_dart()]))
                    }
                    Self::FirmwareDownloadStatus(field0) => {
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([5.into_dart(),
                                        field0.into_into_dart().into_dart()]))
                    }
                    Self::UpgradeProgress(field0) => {
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([6.into_dart(),
                                        field0.into_into_dart().into_dart()]))
                    }
                    Self::AvailableFirmware(field0) => {
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([7.into_dart(),
                                        field0.into_into_dart().into_dart()]))
                    }
                    Self::RecordArchives(field0) => {
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([8.into_dart(),
                                        field0.into_into_dart().into_dart()]))
                    }
                }.into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for DomainMessage {}
    impl rust2dart::IntoIntoDart<DomainMessage> for DomainMessage {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for DownloadProgress {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.started.into_into_dart().into_dart(),
                                self.completed.into_into_dart().into_dart(),
                                self.total.into_into_dart().into_dart(),
                                self.received.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for DownloadProgress {}
    impl rust2dart::IntoIntoDart<DownloadProgress> for DownloadProgress {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for EphemeralConfig {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.transmission.into_dart(),
                                self.networks.into_into_dart().into_dart(),
                                self.capabilities.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for EphemeralConfig {}
    impl rust2dart::IntoIntoDart<EphemeralConfig> for EphemeralConfig {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for FirmwareDownloadStatus {
        fn into_dart(self) -> support::DartAbi {
            match self {
                    Self::Checking =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.into_dart()])),
                    Self::Downloading(field0) =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([1.into_dart(),
                                        field0.into_into_dart().into_dart()])),
                    Self::Offline =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([2.into_dart()])),
                    Self::Completed =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([3.into_dart()])),
                    Self::Failed =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([4.into_dart()])),
                }.into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for FirmwareDownloadStatus {}
    impl rust2dart::IntoIntoDart<FirmwareDownloadStatus> for
        FirmwareDownloadStatus {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for FirmwareInfo {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.label.into_into_dart().into_dart(),
                                self.time.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for FirmwareInfo {}
    impl rust2dart::IntoIntoDart<FirmwareInfo> for FirmwareInfo {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for LocalFirmware {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.id.into_into_dart().into_dart(),
                                self.label.into_into_dart().into_dart(),
                                self.time.into_into_dart().into_dart(),
                                self.module.into_into_dart().into_dart(),
                                self.profile.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for LocalFirmware {}
    impl rust2dart::IntoIntoDart<LocalFirmware> for LocalFirmware {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for ModuleConfig {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.position.into_into_dart().into_dart(),
                                self.module_id.into_into_dart().into_dart(),
                                self.key.into_into_dart().into_dart(),
                                self.sensors.into_into_dart().into_dart(),
                                self.configuration.into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for ModuleConfig {}
    impl rust2dart::IntoIntoDart<ModuleConfig> for ModuleConfig {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for NearbyStation {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.device_id.into_into_dart().into_dart(),
                                self.busy.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for NearbyStation {}
    impl rust2dart::IntoIntoDart<NearbyStation> for NearbyStation {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for NetworkConfig {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.ssid.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for NetworkConfig {}
    impl rust2dart::IntoIntoDart<NetworkConfig> for NetworkConfig {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for RecordArchive {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.device_id.into_into_dart().into_dart(),
                                self.path.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for RecordArchive {}
    impl rust2dart::IntoIntoDart<RecordArchive> for RecordArchive {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for SensorConfig {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.number.into_into_dart().into_dart(),
                                self.key.into_into_dart().into_dart(),
                                self.full_key.into_into_dart().into_dart(),
                                self.calibrated_uom.into_into_dart().into_dart(),
                                self.uncalibrated_uom.into_into_dart().into_dart(),
                                self.value.into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for SensorConfig {}
    impl rust2dart::IntoIntoDart<SensorConfig> for SensorConfig {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for SensorValue {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.time.into_into_dart().into_dart(),
                                self.value.into_into_dart().into_dart(),
                                self.uncalibrated.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for SensorValue {}
    impl rust2dart::IntoIntoDart<SensorValue> for SensorValue {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for SolarInfo {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.voltage.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for SolarInfo {}
    impl rust2dart::IntoIntoDart<SolarInfo> for SolarInfo {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for StationConfig {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.device_id.into_into_dart().into_dart(),
                                self.name.into_into_dart().into_dart(),
                                self.firmware.into_into_dart().into_dart(),
                                self.last_seen.into_into_dart().into_dart(),
                                self.meta.into_into_dart().into_dart(),
                                self.data.into_into_dart().into_dart(),
                                self.battery.into_into_dart().into_dart(),
                                self.solar.into_into_dart().into_dart(),
                                self.modules.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for StationConfig {}
    impl rust2dart::IntoIntoDart<StationConfig> for StationConfig {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for StreamInfo {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.size.into_into_dart().into_dart(),
                                self.records.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for StreamInfo {}
    impl rust2dart::IntoIntoDart<StreamInfo> for StreamInfo {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for Tokens {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.token.into_into_dart().into_dart(),
                                self.transmission.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for Tokens {}
    impl rust2dart::IntoIntoDart<Tokens> for Tokens {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for TransferProgress {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.device_id.into_into_dart().into_dart(),
                                self.status.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for TransferProgress {}
    impl rust2dart::IntoIntoDart<TransferProgress> for TransferProgress {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for TransferStatus {
        fn into_dart(self) -> support::DartAbi {
            match self {
                    Self::Starting =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.into_dart()])),
                    Self::Downloading(field0) =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([1.into_dart(),
                                        field0.into_into_dart().into_dart()])),
                    Self::Uploading(field0) =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([2.into_dart(),
                                        field0.into_into_dart().into_dart()])),
                    Self::Processing =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([3.into_dart()])),
                    Self::Completed =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([4.into_dart()])),
                    Self::Failed =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([5.into_dart()])),
                }.into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for TransferStatus {}
    impl rust2dart::IntoIntoDart<TransferStatus> for TransferStatus {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for TransmissionConfig {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.enabled.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for TransmissionConfig {}
    impl rust2dart::IntoIntoDart<TransmissionConfig> for TransmissionConfig {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for TransmissionToken {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.token.into_into_dart().into_dart(),
                                self.url.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for TransmissionToken {}
    impl rust2dart::IntoIntoDart<TransmissionToken> for TransmissionToken {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for UpgradeProgress {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.device_id.into_into_dart().into_dart(),
                                self.firmware_id.into_into_dart().into_dart(),
                                self.status.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for UpgradeProgress {}
    impl rust2dart::IntoIntoDart<UpgradeProgress> for UpgradeProgress {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for UpgradeStatus {
        fn into_dart(self) -> support::DartAbi {
            match self {
                    Self::Starting =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.into_dart()])),
                    Self::Uploading(field0) =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([1.into_dart(),
                                        field0.into_into_dart().into_dart()])),
                    Self::Restarting =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([2.into_dart()])),
                    Self::Completed =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([3.into_dart()])),
                    Self::Failed =>
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([4.into_dart()])),
                }.into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for UpgradeStatus {}
    impl rust2dart::IntoIntoDart<UpgradeStatus> for UpgradeStatus {
        fn into_into_dart(self) -> Self { self }
    }
    impl support::IntoDart for UploadProgress {
        fn into_dart(self) -> support::DartAbi {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.bytes_uploaded.into_into_dart().into_dart(),
                                self.total_bytes.into_into_dart().into_dart()])).into_dart()
        }
    }
    impl support::IntoDartExceptPrimitive for UploadProgress {}
    impl rust2dart::IntoIntoDart<UploadProgress> for UploadProgress {
        fn into_into_dart(self) -> Self { self }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct FLUTTER_RUST_BRIDGE_HANDLER {
        __private_field: (),
    }
    #[doc(hidden)]
    pub static FLUTTER_RUST_BRIDGE_HANDLER: FLUTTER_RUST_BRIDGE_HANDLER =
        FLUTTER_RUST_BRIDGE_HANDLER { __private_field: () };
    impl ::lazy_static::__Deref for FLUTTER_RUST_BRIDGE_HANDLER {
        type Target = support::DefaultHandler;
        fn deref(&self) -> &support::DefaultHandler {
            #[inline(always)]
            fn __static_ref_initialize() -> support::DefaultHandler {
                Default::default()
            }
            #[inline(always)]
            fn __stability() -> &'static support::DefaultHandler {
                static LAZY:
                    ::lazy_static::lazy::Lazy<support::DefaultHandler> =
                    ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for FLUTTER_RUST_BRIDGE_HANDLER {
        fn initialize(lazy: &Self) { let _ = &**lazy; }
    }
    #[cfg(not(target_family = "wasm"))]
    #[path = "bridge_generated.io.rs"]
    mod io {
        use super::*;
        #[no_mangle]
        pub extern "C" fn wire_start_native(port_: i64,
            storage_path: *mut wire_uint_8_list,
            portal_base_url: *mut wire_uint_8_list) {
            wire_start_native_impl(port_, storage_path, portal_base_url)
        }
        #[no_mangle]
        pub extern "C" fn wire_get_my_stations(port_: i64) {
            wire_get_my_stations_impl(port_)
        }
        #[no_mangle]
        pub extern "C" fn wire_authenticate_portal(port_: i64,
            email: *mut wire_uint_8_list, password: *mut wire_uint_8_list) {
            wire_authenticate_portal_impl(port_, email, password)
        }
        #[no_mangle]
        pub extern "C" fn wire_add_or_update_station_in_portal(port_: i64,
            tokens: *mut wire_Tokens,
            station: *mut wire_AddOrUpdatePortalStation) {
            wire_add_or_update_station_in_portal_impl(port_, tokens, station)
        }
        #[no_mangle]
        pub extern "C" fn wire_configure_wifi_transmission(port_: i64,
            device_id: *mut wire_uint_8_list,
            config: *mut wire_WifiTransmissionConfig) {
            wire_configure_wifi_transmission_impl(port_, device_id, config)
        }
        #[no_mangle]
        pub extern "C" fn wire_clear_calibration(port_: i64,
            device_id: *mut wire_uint_8_list, module: usize) {
            wire_clear_calibration_impl(port_, device_id, module)
        }
        #[no_mangle]
        pub extern "C" fn wire_calibrate(port_: i64,
            device_id: *mut wire_uint_8_list, module: usize,
            data: *mut wire_uint_8_list) {
            wire_calibrate_impl(port_, device_id, module, data)
        }
        #[no_mangle]
        pub extern "C" fn wire_validate_tokens(port_: i64,
            tokens: *mut wire_Tokens) {
            wire_validate_tokens_impl(port_, tokens)
        }
        #[no_mangle]
        pub extern "C" fn wire_start_download(port_: i64,
            device_id: *mut wire_uint_8_list) {
            wire_start_download_impl(port_, device_id)
        }
        #[no_mangle]
        pub extern "C" fn wire_start_upload(port_: i64,
            device_id: *mut wire_uint_8_list, tokens: *mut wire_Tokens,
            files: *mut wire_list_record_archive) {
            wire_start_upload_impl(port_, device_id, tokens, files)
        }
        #[no_mangle]
        pub extern "C" fn wire_cache_firmware(port_: i64,
            tokens: *mut wire_Tokens) {
            wire_cache_firmware_impl(port_, tokens)
        }
        #[no_mangle]
        pub extern "C" fn wire_upgrade_station(port_: i64,
            device_id: *mut wire_uint_8_list,
            firmware: *mut wire_LocalFirmware, swap: bool) {
            wire_upgrade_station_impl(port_, device_id, firmware, swap)
        }
        #[no_mangle]
        pub extern "C" fn wire_rust_release_mode(port_: i64) {
            wire_rust_release_mode_impl(port_)
        }
        #[no_mangle]
        pub extern "C" fn wire_create_log_sink(port_: i64) {
            wire_create_log_sink_impl(port_)
        }
        #[no_mangle]
        pub extern "C" fn new_box_autoadd_add_or_update_portal_station_0()
            -> *mut wire_AddOrUpdatePortalStation {
            support::new_leak_box_ptr(wire_AddOrUpdatePortalStation::new_with_null_ptr())
        }
        #[no_mangle]
        pub extern "C" fn new_box_autoadd_local_firmware_0()
            -> *mut wire_LocalFirmware {
            support::new_leak_box_ptr(wire_LocalFirmware::new_with_null_ptr())
        }
        #[no_mangle]
        pub extern "C" fn new_box_autoadd_tokens_0() -> *mut wire_Tokens {
            support::new_leak_box_ptr(wire_Tokens::new_with_null_ptr())
        }
        #[no_mangle]
        pub extern "C" fn new_box_autoadd_wifi_transmission_config_0()
            -> *mut wire_WifiTransmissionConfig {
            support::new_leak_box_ptr(wire_WifiTransmissionConfig::new_with_null_ptr())
        }
        #[no_mangle]
        pub extern "C" fn new_list_record_archive_0(len: i32)
            -> *mut wire_list_record_archive {
            let wrap =
                wire_list_record_archive {
                    ptr: support::new_leak_vec_ptr(<wire_RecordArchive>::new_with_null_ptr(),
                        len),
                    len,
                };
            support::new_leak_box_ptr(wrap)
        }
        #[no_mangle]
        pub extern "C" fn new_uint_8_list_0(len: i32)
            -> *mut wire_uint_8_list {
            let ans =
                wire_uint_8_list {
                    ptr: support::new_leak_vec_ptr(Default::default(), len),
                    len,
                };
            support::new_leak_box_ptr(ans)
        }
        impl Wire2Api<String> for *mut wire_uint_8_list {
            fn wire2api(self) -> String {
                let vec: Vec<u8> = self.wire2api();
                String::from_utf8_lossy(&vec).into_owned()
            }
        }
        impl Wire2Api<AddOrUpdatePortalStation> for
            wire_AddOrUpdatePortalStation {
            fn wire2api(self) -> AddOrUpdatePortalStation {
                AddOrUpdatePortalStation {
                    name: self.name.wire2api(),
                    device_id: self.device_id.wire2api(),
                    location_name: self.location_name.wire2api(),
                    status_pb: self.status_pb.wire2api(),
                }
            }
        }
        impl Wire2Api<AddOrUpdatePortalStation> for
            *mut wire_AddOrUpdatePortalStation {
            fn wire2api(self) -> AddOrUpdatePortalStation {
                let wrap = unsafe { support::box_from_leak_ptr(self) };
                Wire2Api::<AddOrUpdatePortalStation>::wire2api(*wrap).into()
            }
        }
        impl Wire2Api<LocalFirmware> for *mut wire_LocalFirmware {
            fn wire2api(self) -> LocalFirmware {
                let wrap = unsafe { support::box_from_leak_ptr(self) };
                Wire2Api::<LocalFirmware>::wire2api(*wrap).into()
            }
        }
        impl Wire2Api<Tokens> for *mut wire_Tokens {
            fn wire2api(self) -> Tokens {
                let wrap = unsafe { support::box_from_leak_ptr(self) };
                Wire2Api::<Tokens>::wire2api(*wrap).into()
            }
        }
        impl Wire2Api<WifiTransmissionConfig> for
            *mut wire_WifiTransmissionConfig {
            fn wire2api(self) -> WifiTransmissionConfig {
                let wrap = unsafe { support::box_from_leak_ptr(self) };
                Wire2Api::<WifiTransmissionConfig>::wire2api(*wrap).into()
            }
        }
        impl Wire2Api<Vec<RecordArchive>> for *mut wire_list_record_archive {
            fn wire2api(self) -> Vec<RecordArchive> {
                let vec =
                    unsafe {
                        let wrap = support::box_from_leak_ptr(self);
                        support::vec_from_leak_ptr(wrap.ptr, wrap.len)
                    };
                vec.into_iter().map(Wire2Api::wire2api).collect()
            }
        }
        impl Wire2Api<LocalFirmware> for wire_LocalFirmware {
            fn wire2api(self) -> LocalFirmware {
                LocalFirmware {
                    id: self.id.wire2api(),
                    label: self.label.wire2api(),
                    time: self.time.wire2api(),
                    module: self.module.wire2api(),
                    profile: self.profile.wire2api(),
                }
            }
        }
        impl Wire2Api<RecordArchive> for wire_RecordArchive {
            fn wire2api(self) -> RecordArchive {
                RecordArchive {
                    device_id: self.device_id.wire2api(),
                    path: self.path.wire2api(),
                }
            }
        }
        impl Wire2Api<Tokens> for wire_Tokens {
            fn wire2api(self) -> Tokens {
                Tokens {
                    token: self.token.wire2api(),
                    transmission: self.transmission.wire2api(),
                }
            }
        }
        impl Wire2Api<TransmissionToken> for wire_TransmissionToken {
            fn wire2api(self) -> TransmissionToken {
                TransmissionToken {
                    token: self.token.wire2api(),
                    url: self.url.wire2api(),
                }
            }
        }
        impl Wire2Api<Vec<u8>> for *mut wire_uint_8_list {
            fn wire2api(self) -> Vec<u8> {
                unsafe {
                    let wrap = support::box_from_leak_ptr(self);
                    support::vec_from_leak_ptr(wrap.ptr, wrap.len)
                }
            }
        }
        impl Wire2Api<WifiTransmissionConfig> for wire_WifiTransmissionConfig
            {
            fn wire2api(self) -> WifiTransmissionConfig {
                WifiTransmissionConfig { tokens: self.tokens.wire2api() }
            }
        }
        #[repr(C)]
        pub struct wire_AddOrUpdatePortalStation {
            name: *mut wire_uint_8_list,
            device_id: *mut wire_uint_8_list,
            location_name: *mut wire_uint_8_list,
            status_pb: *mut wire_uint_8_list,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for wire_AddOrUpdatePortalStation {
            #[inline]
            fn clone(&self) -> wire_AddOrUpdatePortalStation {
                wire_AddOrUpdatePortalStation {
                    name: ::core::clone::Clone::clone(&self.name),
                    device_id: ::core::clone::Clone::clone(&self.device_id),
                    location_name: ::core::clone::Clone::clone(&self.location_name),
                    status_pb: ::core::clone::Clone::clone(&self.status_pb),
                }
            }
        }
        #[repr(C)]
        pub struct wire_list_record_archive {
            ptr: *mut wire_RecordArchive,
            len: i32,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for wire_list_record_archive {
            #[inline]
            fn clone(&self) -> wire_list_record_archive {
                wire_list_record_archive {
                    ptr: ::core::clone::Clone::clone(&self.ptr),
                    len: ::core::clone::Clone::clone(&self.len),
                }
            }
        }
        #[repr(C)]
        pub struct wire_LocalFirmware {
            id: i64,
            label: *mut wire_uint_8_list,
            time: i64,
            module: *mut wire_uint_8_list,
            profile: *mut wire_uint_8_list,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for wire_LocalFirmware {
            #[inline]
            fn clone(&self) -> wire_LocalFirmware {
                wire_LocalFirmware {
                    id: ::core::clone::Clone::clone(&self.id),
                    label: ::core::clone::Clone::clone(&self.label),
                    time: ::core::clone::Clone::clone(&self.time),
                    module: ::core::clone::Clone::clone(&self.module),
                    profile: ::core::clone::Clone::clone(&self.profile),
                }
            }
        }
        #[repr(C)]
        pub struct wire_RecordArchive {
            device_id: *mut wire_uint_8_list,
            path: *mut wire_uint_8_list,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for wire_RecordArchive {
            #[inline]
            fn clone(&self) -> wire_RecordArchive {
                wire_RecordArchive {
                    device_id: ::core::clone::Clone::clone(&self.device_id),
                    path: ::core::clone::Clone::clone(&self.path),
                }
            }
        }
        #[repr(C)]
        pub struct wire_Tokens {
            token: *mut wire_uint_8_list,
            transmission: wire_TransmissionToken,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for wire_Tokens {
            #[inline]
            fn clone(&self) -> wire_Tokens {
                wire_Tokens {
                    token: ::core::clone::Clone::clone(&self.token),
                    transmission: ::core::clone::Clone::clone(&self.transmission),
                }
            }
        }
        #[repr(C)]
        pub struct wire_TransmissionToken {
            token: *mut wire_uint_8_list,
            url: *mut wire_uint_8_list,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for wire_TransmissionToken {
            #[inline]
            fn clone(&self) -> wire_TransmissionToken {
                wire_TransmissionToken {
                    token: ::core::clone::Clone::clone(&self.token),
                    url: ::core::clone::Clone::clone(&self.url),
                }
            }
        }
        #[repr(C)]
        pub struct wire_uint_8_list {
            ptr: *mut u8,
            len: i32,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for wire_uint_8_list {
            #[inline]
            fn clone(&self) -> wire_uint_8_list {
                wire_uint_8_list {
                    ptr: ::core::clone::Clone::clone(&self.ptr),
                    len: ::core::clone::Clone::clone(&self.len),
                }
            }
        }
        #[repr(C)]
        pub struct wire_WifiTransmissionConfig {
            tokens: *mut wire_Tokens,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for wire_WifiTransmissionConfig {
            #[inline]
            fn clone(&self) -> wire_WifiTransmissionConfig {
                wire_WifiTransmissionConfig {
                    tokens: ::core::clone::Clone::clone(&self.tokens),
                }
            }
        }
        pub trait NewWithNullPtr {
            fn new_with_null_ptr()
            -> Self;
        }
        impl<T> NewWithNullPtr for *mut T {
            fn new_with_null_ptr() -> Self { std::ptr::null_mut() }
        }
        impl NewWithNullPtr for wire_AddOrUpdatePortalStation {
            fn new_with_null_ptr() -> Self {
                Self {
                    name: core::ptr::null_mut(),
                    device_id: core::ptr::null_mut(),
                    location_name: core::ptr::null_mut(),
                    status_pb: core::ptr::null_mut(),
                }
            }
        }
        impl Default for wire_AddOrUpdatePortalStation {
            fn default() -> Self { Self::new_with_null_ptr() }
        }
        impl NewWithNullPtr for wire_LocalFirmware {
            fn new_with_null_ptr() -> Self {
                Self {
                    id: Default::default(),
                    label: core::ptr::null_mut(),
                    time: Default::default(),
                    module: core::ptr::null_mut(),
                    profile: core::ptr::null_mut(),
                }
            }
        }
        impl Default for wire_LocalFirmware {
            fn default() -> Self { Self::new_with_null_ptr() }
        }
        impl NewWithNullPtr for wire_RecordArchive {
            fn new_with_null_ptr() -> Self {
                Self {
                    device_id: core::ptr::null_mut(),
                    path: core::ptr::null_mut(),
                }
            }
        }
        impl Default for wire_RecordArchive {
            fn default() -> Self { Self::new_with_null_ptr() }
        }
        impl NewWithNullPtr for wire_Tokens {
            fn new_with_null_ptr() -> Self {
                Self {
                    token: core::ptr::null_mut(),
                    transmission: Default::default(),
                }
            }
        }
        impl Default for wire_Tokens {
            fn default() -> Self { Self::new_with_null_ptr() }
        }
        impl NewWithNullPtr for wire_TransmissionToken {
            fn new_with_null_ptr() -> Self {
                Self {
                    token: core::ptr::null_mut(),
                    url: core::ptr::null_mut(),
                }
            }
        }
        impl Default for wire_TransmissionToken {
            fn default() -> Self { Self::new_with_null_ptr() }
        }
        impl NewWithNullPtr for wire_WifiTransmissionConfig {
            fn new_with_null_ptr() -> Self {
                Self { tokens: core::ptr::null_mut() }
            }
        }
        impl Default for wire_WifiTransmissionConfig {
            fn default() -> Self { Self::new_with_null_ptr() }
        }
        #[no_mangle]
        pub extern "C" fn free_WireSyncReturn(ptr: support::WireSyncReturn) {
            unsafe { let _ = support::box_from_leak_ptr(ptr); };
        }
    }
    #[cfg(not(target_family = "wasm"))]
    pub use io::*;
}
mod firmware {
    use anyhow::{anyhow, Context, Result};
    use discovery::DeviceId;
    use query::portal::Firmware;
    use std::path::PathBuf;
    use tokio::{
        fs::OpenOptions, io::{AsyncReadExt, AsyncWriteExt},
        pin, sync::mpsc::Sender,
    };
    use tokio_stream::StreamExt;
    use tracing::*;
    use crate::nearby::NearbyDevices;
    use super::api::*;
    pub struct CheckForAndCacheFirmware {
        portal_base_url: String,
        storage_path: String,
        publish_tx: Sender<DomainMessage>,
        tokens: Option<Tokens>,
    }
    impl CheckForAndCacheFirmware {
        async fn run(&self) -> Result<()> {
            let cached =
                match check_cached_firmware(&self.storage_path).await {
                    Err(e) => {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                {
                                    static META: ::tracing::Metadata<'static> =
                                        {
                                            ::tracing_core::metadata::Metadata::new("event src/firmware.rs:29",
                                                "native::firmware", ::tracing::Level::WARN,
                                                Some("src/firmware.rs"), Some(29u32),
                                                Some("native::firmware"),
                                                ::tracing_core::field::FieldSet::new(&["message"],
                                                    ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                ::tracing::metadata::Kind::EVENT)
                                        };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                            let enabled =
                                ::tracing::Level::WARN <=
                                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                        ::tracing::Level::WARN <=
                                            ::tracing::level_filters::LevelFilter::current() &&
                                    {
                                        let interest = CALLSITE.interest();
                                        !interest.is_never() &&
                                            ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                interest)
                                    };
                            if enabled {
                                    (|value_set: ::tracing::field::ValueSet|
                                                {
                                                    let meta = CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                    ;
                                                })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                Some(&format_args!("Error checking cached firmware: {0:?}",
                                                                                e) as &dyn Value))])
                                        });
                                } else { ; }
                        };
                        self.publish_tx.send(DomainMessage::FirmwareDownloadStatus(FirmwareDownloadStatus::Failed)).await?;
                        return Ok(());
                    }
                    Ok(cached) => cached,
                };
            match cache_firmware_and_json_if_newer(self.publish_tx.clone(),
                        &self.portal_base_url, &self.storage_path,
                        self.tokens.clone(), cached).await {
                Err(e) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/firmware.rs:52",
                                            "native::firmware", ::tracing::Level::WARN,
                                            Some("src/firmware.rs"), Some(52u32),
                                            Some("native::firmware"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::WARN <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::WARN <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("Error caching firmware: {0:?}", e) as
                                                                    &dyn Value))])
                                    });
                            } else { ; }
                    };
                    self.publish_tx.send(DomainMessage::FirmwareDownloadStatus(FirmwareDownloadStatus::Offline)).await?;
                    return Ok(());
                }
                Ok(_) => {}
            };
            Ok(())
        }
    }
    pub async fn cache_firmware(portal_base_url: String, storage_path: String,
        publish_tx: Sender<DomainMessage>, tokens: Option<Tokens>)
        -> Result<FirmwareDownloadStatus> {
        let task =
            CheckForAndCacheFirmware {
                portal_base_url,
                storage_path,
                publish_tx,
                tokens,
            };
        tokio::task::spawn(async move
                {
                match task.run().await {
                    Err(e) => {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/firmware.rs:83",
                                            "native::firmware", ::tracing::Level::WARN,
                                            Some("src/firmware.rs"), Some(83u32),
                                            Some("native::firmware"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::WARN <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::WARN <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("Error caching firmware: {0:?}", e) as
                                                                    &dyn Value))])
                                    });
                            } else { ; }
                    }
                    Ok(_) => {}
                }
            });
        Ok(FirmwareDownloadStatus::Checking)
    }
    pub struct FirmwareUpgrader {
        nearby: NearbyDevices,
        publish_tx: Sender<DomainMessage>,
        storage_path: String,
        device_id: DeviceId,
        firmware: LocalFirmware,
        swap: bool,
        addr: String,
    }
    impl FirmwareUpgrader {
        async fn publish(&self, status: UpgradeStatus) -> Result<()> {
            Ok(self.publish_tx.send(DomainMessage::UpgradeProgress(UpgradeProgress {
                                    device_id: self.device_id.0.clone(),
                                    firmware_id: self.firmware.id,
                                    status,
                                })).await?)
        }
        async fn run(&self) -> Result<()> {
            let path =
                PathBuf::from(&self.storage_path).join({
                        let res =
                            ::alloc::fmt::format(format_args!("firmware-{0}.bin",
                                    self.firmware.id));
                        res
                    });
            let device_id = self.device_id.clone();
            let client = query::device::Client::new()?;
            match client.upgrade(&self.addr, &path, self.swap).await {
                Ok(mut stream) => {
                    let mut failed = false;
                    while let Some(res) = stream.next().await {
                        match res {
                            Ok(bytes) => {
                                self.publish(UpgradeStatus::Uploading(UploadProgress {
                                                    bytes_uploaded: bytes.bytes_uploaded,
                                                    total_bytes: bytes.total_bytes,
                                                })).await?;
                            }
                            Err(_) => {
                                self.publish(UpgradeStatus::Failed).await?;
                                failed = true;
                            }
                        }
                    }
                    if !failed {
                            if self.swap {
                                    self.publish(UpgradeStatus::Restarting).await?;
                                    match wait_for_station_restart(&self.addr).await {
                                        Ok(_) => { self.publish(UpgradeStatus::Completed).await?; }
                                        Err(_) => { self.publish(UpgradeStatus::Failed).await?; }
                                    }
                                } else { self.publish(UpgradeStatus::Completed).await?; }
                        }
                    self.nearby.mark_busy(&device_id, false).await?;
                    Ok(())
                }
                Err(e) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/firmware.rs:162",
                                            "native::firmware", ::tracing::Level::WARN,
                                            Some("src/firmware.rs"), Some(162u32),
                                            Some("native::firmware"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::WARN <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::WARN <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("Error: {0:?}", e) as &dyn Value))])
                                    });
                            } else { ; }
                    };
                    self.publish(UpgradeStatus::Failed).await?;
                    self.nearby.mark_busy(&device_id, false).await?;
                    Ok(())
                }
            }
        }
    }
    pub async fn upgrade(nearby: NearbyDevices,
        publish_tx: Sender<DomainMessage>, storage_path: String,
        device_id: DeviceId, firmware: LocalFirmware, swap: bool,
        addr: String) -> Result<UpgradeProgress> {
        let upgrader =
            FirmwareUpgrader {
                nearby: nearby.clone(),
                publish_tx,
                storage_path,
                device_id: device_id.clone(),
                firmware: firmware.clone(),
                swap,
                addr,
            };
        nearby.mark_busy(&device_id, true).await?;
        tokio::task::spawn(async move
                {
                match upgrader.run().await {
                    Err(e) => {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/firmware.rs:197",
                                            "native::firmware", ::tracing::Level::WARN,
                                            Some("src/firmware.rs"), Some(197u32),
                                            Some("native::firmware"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::WARN <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::WARN <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("Error upgrading: {0:?}", e) as
                                                                    &dyn Value))])
                                    });
                            } else { ; }
                    }
                    Ok(_) => {}
                }
            });
        Ok(UpgradeProgress {
                device_id: device_id.0.clone(),
                firmware_id: firmware.id,
                status: UpgradeStatus::Starting,
            })
    }
    async fn wait_for_station_restart(addr: &str) -> Result<()> {
        use std::time::Duration;
        use tokio::time::sleep;
        for i in 0..30 {
            sleep(Duration::from_secs(if i == 0 { 5 } else { 1 })).await;
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                    {
                        static META: ::tracing::Metadata<'static> =
                            {
                                ::tracing_core::metadata::Metadata::new("event src/firmware.rs:216",
                                    "native::firmware", ::tracing::Level::INFO,
                                    Some("src/firmware.rs"), Some(216u32),
                                    Some("native::firmware"),
                                    ::tracing_core::field::FieldSet::new(&["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                    ::tracing::metadata::Kind::EVENT)
                            };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                let enabled =
                    ::tracing::Level::INFO <=
                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                            ::tracing::Level::INFO <=
                                ::tracing::level_filters::LevelFilter::current() &&
                        {
                            let interest = CALLSITE.interest();
                            !interest.is_never() &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest)
                        };
                if enabled {
                        (|value_set: ::tracing::field::ValueSet|
                                    {
                                        let meta = CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        ;
                                    })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&format_args!("upgrade: Checking station") as
                                                            &dyn Value))])
                            });
                    } else { ; }
            };
            let client = query::device::Client::new()?;
            match client.query_status(addr).await {
                Err(e) => {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite =
                        {
                            static META: ::tracing::Metadata<'static> =
                                {
                                    ::tracing_core::metadata::Metadata::new("event src/firmware.rs:219",
                                        "native::firmware", ::tracing::Level::INFO,
                                        Some("src/firmware.rs"), Some(219u32),
                                        Some("native::firmware"),
                                        ::tracing_core::field::FieldSet::new(&["message"],
                                            ::tracing_core::callsite::Identifier(&CALLSITE)),
                                        ::tracing::metadata::Kind::EVENT)
                                };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                    let enabled =
                        ::tracing::Level::INFO <=
                                    ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                ::tracing::Level::INFO <=
                                    ::tracing::level_filters::LevelFilter::current() &&
                            {
                                let interest = CALLSITE.interest();
                                !interest.is_never() &&
                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                        interest)
                            };
                    if enabled {
                            (|value_set: ::tracing::field::ValueSet|
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            ;
                                        })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = CALLSITE.metadata().fields().iter();
                                    CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&format_args!("upgrade: Waiting for station: {0:?}", e)
                                                                as &dyn Value))])
                                });
                        } else { ; }
                }
                Ok(_) => { return Ok(()); }
            }
        }
        Err(::anyhow::__private::must_use({
                    let error =
                        ::anyhow::__private::format_err(format_args!("Station did not come back online."));
                    error
                }))
    }
    async fn check_cached_firmware(storage_path: &str)
        -> Result<Vec<Firmware>> {
        let mut found = Vec::new();
        let pattern =
            {
                let res =
                    ::alloc::fmt::format(format_args!("{0}/firmware*.json",
                            storage_path));
                res
            };
        for path in glob::glob(&pattern)? {
            let mut reading =
                OpenOptions::new().read(true).open(&path?).await?;
            let mut buffer = String::new();
            reading.read_to_string(&mut buffer).await?;
            found.push(serde_json::from_str(&buffer)?);
        }
        Ok(found)
    }
    async fn publish_available_firmware(storage_path: &str,
        publish_tx: Sender<DomainMessage>) -> Result<()> {
        use itertools::*;
        let firmware = check_cached_firmware(storage_path).await?;
        let local =
            firmware.into_iter().map(|f|
                                        f.into()).collect::<Vec<LocalFirmware>>().into_iter().sorted_unstable_by_key(|i|
                            i.time).rev().collect();
        publish_tx.send(DomainMessage::AvailableFirmware(local)).await?;
        Ok(())
    }
    impl From<Firmware> for LocalFirmware {
        fn from(value: Firmware) -> Self {
            Self {
                id: value.id,
                time: value.time.timestamp_millis(),
                label: value.version,
                module: value.module,
                profile: value.profile,
            }
        }
    }
    async fn query_available_firmware(client: &query::portal::Client,
        tokens: Option<Tokens>) -> Result<Vec<Firmware>> {
        if let Some(tokens) = tokens {
                client.to_authenticated(tokens.into())?.available_firmware().await
            } else { client.available_firmware().await }
    }
    async fn cache_firmware_and_json_if_newer(publish_tx:
            Sender<DomainMessage>, portal_base_url: &str, storage_path: &str,
        tokens: Option<Tokens>, cached: Vec<Firmware>) -> Result<()> {
        let client = query::portal::Client::new(portal_base_url)?;
        let firmwares = query_available_firmware(&client, tokens).await?;
        for firmware in firmwares.iter() {
            let has = cached.iter().any(|f| f.etag == firmware.etag);
            if has {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/firmware.rs:304",
                                            "native::firmware", ::tracing::Level::INFO,
                                            Some("src/firmware.rs"), Some(304u32),
                                            Some("native::firmware"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::INFO <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::INFO <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("Firmware already cached {0:?} ({1})",
                                                                            firmware.etag, storage_path) as &dyn Value))])
                                    });
                            } else { ; }
                    };
                    continue;
                }
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                    {
                        static META: ::tracing::Metadata<'static> =
                            {
                                ::tracing_core::metadata::Metadata::new("event src/firmware.rs:311",
                                    "native::firmware", ::tracing::Level::INFO,
                                    Some("src/firmware.rs"), Some(311u32),
                                    Some("native::firmware"),
                                    ::tracing_core::field::FieldSet::new(&["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                    ::tracing::metadata::Kind::EVENT)
                            };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                let enabled =
                    ::tracing::Level::INFO <=
                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                            ::tracing::Level::INFO <=
                                ::tracing::level_filters::LevelFilter::current() &&
                        {
                            let interest = CALLSITE.interest();
                            !interest.is_never() &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest)
                        };
                if enabled {
                        (|value_set: ::tracing::field::ValueSet|
                                    {
                                        let meta = CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        ;
                                    })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&format_args!("New firmware! {0:?}", firmware.etag) as
                                                            &dyn Value))])
                            });
                    } else { ; }
            };
            let path =
                PathBuf::from(storage_path).join({
                        let res =
                            ::alloc::fmt::format(format_args!("firmware-{0}.bin",
                                    firmware.id));
                        res
                    });
            let stream = client.download_firmware(firmware, &path).await?;
            let mut stream = stream;
            #[allow(unused_mut)]
            let mut stream =
                unsafe {
                    ::tokio::macros::support::Pin::new_unchecked(&mut stream)
                };
            while let Some(Ok(bytes)) = stream.next().await {
                publish_tx.send(DomainMessage::FirmwareDownloadStatus(FirmwareDownloadStatus::Downloading(DownloadProgress {
                                        started: 0,
                                        completed: 0.0,
                                        total: bytes.total_bytes as usize,
                                        received: bytes.bytes_downloaded as usize,
                                    }))).await?;
            }
            let path =
                PathBuf::from(storage_path).join({
                        let res =
                            ::alloc::fmt::format(format_args!("firmware-{0}.json",
                                    firmware.id));
                        res
                    });
            let mut writing =
                OpenOptions::new().write(true).create(true).truncate(true).open(&path).await.with_context(||
                            {
                                let res =
                                    ::alloc::fmt::format(format_args!("Creating {0:?}", &path));
                                res
                            })?;
            writing.write_all(&serde_json::to_vec(firmware)?).await?;
            publish_available_firmware(storage_path,
                        publish_tx.clone()).await?;
        }
        if firmwares.is_empty() {
                publish_available_firmware(storage_path,
                            publish_tx.clone()).await?;
            }
        Ok(())
    }
}
mod nearby {
    use anyhow::Result;
    use base64::Engine;
    use chrono::{DateTime, Duration, Utc};
    use std::{collections::HashMap, ops::Sub, sync::Arc, time::UNIX_EPOCH};
    use sync::ServerEvent;
    use tokio::{
        sync::{
            mpsc::{Receiver, Sender},
            Mutex,
        },
        time::Instant,
    };
    use tracing::*;
    use discovery::{DeviceId, Discovered};
    use query::device::{HttpReply, RawAndDecoded};
    use crate::api::{
        DomainMessage, DownloadProgress, NearbyStation, RecordArchive,
        TransferProgress, TransferStatus,
    };
    pub enum BackgroundMessage {
        Domain(DomainMessage),
        StationReply(DeviceId, HttpReply, String),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BackgroundMessage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                BackgroundMessage::Domain(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Domain", &__self_0),
                BackgroundMessage::StationReply(__self_0, __self_1, __self_2)
                    =>
                    ::core::fmt::Formatter::debug_tuple_field3_finish(f,
                        "StationReply", __self_0, __self_1, &__self_2),
            }
        }
    }
    pub struct NearbyDevices {
        publish_tx: Sender<BackgroundMessage>,
        devices: Arc<Mutex<HashMap<DeviceId, Querying>>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NearbyDevices {
        #[inline]
        fn clone(&self) -> NearbyDevices {
            NearbyDevices {
                publish_tx: ::core::clone::Clone::clone(&self.publish_tx),
                devices: ::core::clone::Clone::clone(&self.devices),
            }
        }
    }
    const ONE_SECOND: std::time::Duration = std::time::Duration::from_secs(1);
    impl NearbyDevices {
        pub fn new(publish_tx: Sender<BackgroundMessage>) -> Self {
            Self { publish_tx, devices: Default::default() }
        }
        pub async fn run(&self, mut rx: Receiver<Discovered>,
            mut transfer_events: Receiver<ServerEvent>) -> Result<()> {
            let maintain_discoveries =
                tokio::spawn({
                        let nearby = self.clone();
                        async move
                            {
                            while let Some(discovered) = rx.recv().await {
                                match nearby.discovered(discovered).await {
                                    Err(e) => {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("event src/nearby.rs:54",
                                                            "native::nearby", ::tracing::Level::WARN,
                                                            Some("src/nearby.rs"), Some(54u32), Some("native::nearby"),
                                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::EVENT)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let enabled =
                                            ::tracing::Level::WARN <=
                                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                    ::tracing::Level::WARN <=
                                                        ::tracing::level_filters::LevelFilter::current() &&
                                                {
                                                    let interest = CALLSITE.interest();
                                                    !interest.is_never() &&
                                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                            interest)
                                                };
                                        if enabled {
                                                (|value_set: ::tracing::field::ValueSet|
                                                            {
                                                                let meta = CALLSITE.metadata();
                                                                ::tracing::Event::dispatch(meta, &value_set);
                                                                ;
                                                            })({
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = CALLSITE.metadata().fields().iter();
                                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&format_args!("Error handling discovered: {0}", e) as
                                                                                    &dyn Value))])
                                                    });
                                            } else { ; }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    });
            let query_stations =
                tokio::spawn({
                        let nearby = self.clone();
                        async move
                            {
                            loop {
                                match nearby.schedule_queries().await {
                                    Err(e) => {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("event src/nearby.rs:66",
                                                            "native::nearby", ::tracing::Level::WARN,
                                                            Some("src/nearby.rs"), Some(66u32), Some("native::nearby"),
                                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::EVENT)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let enabled =
                                            ::tracing::Level::WARN <=
                                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                    ::tracing::Level::WARN <=
                                                        ::tracing::level_filters::LevelFilter::current() &&
                                                {
                                                    let interest = CALLSITE.interest();
                                                    !interest.is_never() &&
                                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                            interest)
                                                };
                                        if enabled {
                                                (|value_set: ::tracing::field::ValueSet|
                                                            {
                                                                let meta = CALLSITE.metadata();
                                                                ::tracing::Event::dispatch(meta, &value_set);
                                                                ;
                                                            })({
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = CALLSITE.metadata().fields().iter();
                                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&format_args!("Error scheduling queries: {0}", e) as
                                                                                    &dyn Value))])
                                                    });
                                            } else { ; }
                                    }
                                    Ok(false) => tokio::time::sleep(ONE_SECOND).await,
                                    Ok(true) => {}
                                }
                            }
                        }
                    });
            let handle_server_events =
                tokio::spawn({
                        let publish_tx = self.publish_tx.clone();
                        let nearby = self.clone();
                        async move
                            {
                            let mut last_progress = None::<Instant>;
                            while let Some(event) = transfer_events.recv().await {
                                match nearby.handle_server_event(publish_tx.clone(),
                                            &mut last_progress, event).await {
                                    Err(e) => {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("event src/nearby.rs:84",
                                                            "native::nearby", ::tracing::Level::WARN,
                                                            Some("src/nearby.rs"), Some(84u32), Some("native::nearby"),
                                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::EVENT)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let enabled =
                                            ::tracing::Level::WARN <=
                                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                    ::tracing::Level::WARN <=
                                                        ::tracing::level_filters::LevelFilter::current() &&
                                                {
                                                    let interest = CALLSITE.interest();
                                                    !interest.is_never() &&
                                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                            interest)
                                                };
                                        if enabled {
                                                (|value_set: ::tracing::field::ValueSet|
                                                            {
                                                                let meta = CALLSITE.metadata();
                                                                ::tracing::Event::dispatch(meta, &value_set);
                                                                ;
                                                            })({
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = CALLSITE.metadata().fields().iter();
                                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&format_args!("Error handling server event: {0}", e) as
                                                                                    &dyn Value))])
                                                    });
                                            } else { ; }
                                    }
                                    Ok(_) => {}
                                }
                            }
                        }
                    });
            {
                #[doc(hidden)]
                mod __tokio_select_util {
                    pub(super) enum Out<_0, _1, _2> {
                        _0(_0),
                        _1(_1),
                        _2(_2),
                        Disabled,
                    }
                    pub(super) type Mask = u8;
                }
                use ::tokio::macros::support::Future;
                use ::tokio::macros::support::Pin;
                use ::tokio::macros::support::Poll::{Ready, Pending};
                const BRANCHES: u32 = 3;
                let mut disabled: __tokio_select_util::Mask =
                    Default::default();
                if !true {
                        let mask: __tokio_select_util::Mask = 1 << 0;
                        disabled |= mask;
                    }
                if !true {
                        let mask: __tokio_select_util::Mask = 1 << 1;
                        disabled |= mask;
                    }
                if !true {
                        let mask: __tokio_select_util::Mask = 1 << 2;
                        disabled |= mask;
                    }
                let mut output =
                    {
                        let mut futures =
                            (maintain_discoveries, query_stations,
                                handle_server_events);
                        let mut futures = &mut futures;
                        ::tokio::macros::support::poll_fn(|cx|
                                    {
                                        let mut is_pending = false;
                                        let start =
                                            { ::tokio::macros::support::thread_rng_n(BRANCHES) };
                                        for i in 0..BRANCHES {
                                            let branch;

                                            #[allow(clippy :: modulo_one)]
                                            { branch = (start + i) % BRANCHES; }
                                            match branch
                                                {
                                                    #[allow(unreachable_code)]
                                                    0 => {
                                                    let mask = 1 << branch;
                                                    if disabled & mask == mask { continue; }
                                                    let (fut, ..) = &mut *futures;
                                                    let mut fut = unsafe { Pin::new_unchecked(fut) };
                                                    let out =
                                                        match Future::poll(fut, cx) {
                                                            Ready(out) => out,
                                                            Pending => { is_pending = true; continue; }
                                                        };
                                                    disabled |= mask;

                                                    #[allow(unused_variables)]
                                                    #[allow(unused_mut)]
                                                    match &out { _ => {} _ => continue, }
                                                    return Ready(__tokio_select_util::Out::_0(out));
                                                }
                                                    #[allow(unreachable_code)]
                                                    1 => {
                                                    let mask = 1 << branch;
                                                    if disabled & mask == mask { continue; }
                                                    let (_, fut, ..) = &mut *futures;
                                                    let mut fut = unsafe { Pin::new_unchecked(fut) };
                                                    let out =
                                                        match Future::poll(fut, cx) {
                                                            Ready(out) => out,
                                                            Pending => { is_pending = true; continue; }
                                                        };
                                                    disabled |= mask;

                                                    #[allow(unused_variables)]
                                                    #[allow(unused_mut)]
                                                    match &out { _ => {} _ => continue, }
                                                    return Ready(__tokio_select_util::Out::_1(out));
                                                }
                                                    #[allow(unreachable_code)]
                                                    2 => {
                                                    let mask = 1 << branch;
                                                    if disabled & mask == mask { continue; }
                                                    let (_, _, fut, ..) = &mut *futures;
                                                    let mut fut = unsafe { Pin::new_unchecked(fut) };
                                                    let out =
                                                        match Future::poll(fut, cx) {
                                                            Ready(out) => out,
                                                            Pending => { is_pending = true; continue; }
                                                        };
                                                    disabled |= mask;

                                                    #[allow(unused_variables)]
                                                    #[allow(unused_mut)]
                                                    match &out { _ => {} _ => continue, }
                                                    return Ready(__tokio_select_util::Out::_2(out));
                                                }
                                                _ => {
                                                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                                            format_args!("reaching this means there probably is an off by one bug")));
                                                }
                                            }
                                        }
                                        if is_pending {
                                                Pending
                                            } else { Ready(__tokio_select_util::Out::Disabled) }
                                    }).await
                    };
                match output {
                    __tokio_select_util::Out::_0(_) => Ok(()),
                    __tokio_select_util::Out::_1(_) => Ok(()),
                    __tokio_select_util::Out::_2(_) => Ok(()),
                    __tokio_select_util::Out::Disabled => {
                        ::core::panicking::panic_fmt(format_args!("all branches are disabled and there is no else branch"));
                    }
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("failed to match bind")));
                    }
                }
            }
        }
        pub async fn get_connections(&self)
            -> Result<HashMap<DeviceId, Connection>> {
            let devices = self.devices.lock().await;
            Ok(devices.iter().map(|(key, value)|
                            (key.clone(), value.into())).collect())
        }
        pub async fn discovered(&self, discovered: Discovered) -> Result<()> {
            if self.add_if_necessary(discovered).await? {
                    Ok(self.publish().await?)
                } else { Ok(()) }
        }
        pub async fn schedule_queries(&self) -> Result<bool> {
            match self.first_station_to_query().await? {
                Some(querying) =>
                    match self.query_station(&querying).await {
                        Ok(status) =>
                            Ok(self.mark_finished_and_publish_reply(&querying.device_id,
                                                status).await.map(|_| true)?),
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                    {
                                        static META: ::tracing::Metadata<'static> =
                                            {
                                                ::tracing_core::metadata::Metadata::new("event src/nearby.rs:122",
                                                    "native::nearby", ::tracing::Level::WARN,
                                                    Some("src/nearby.rs"), Some(122u32), Some("native::nearby"),
                                                    ::tracing_core::field::FieldSet::new(&["message"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                    ::tracing::metadata::Kind::EVENT)
                                            };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                let enabled =
                                    ::tracing::Level::WARN <=
                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                            ::tracing::Level::WARN <=
                                                ::tracing::level_filters::LevelFilter::current() &&
                                        {
                                            let interest = CALLSITE.interest();
                                            !interest.is_never() &&
                                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                    interest)
                                        };
                                if enabled {
                                        (|value_set: ::tracing::field::ValueSet|
                                                    {
                                                        let meta = CALLSITE.metadata();
                                                        ::tracing::Event::dispatch(meta, &value_set);
                                                        ;
                                                    })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&format_args!("Query station: {0}", e) as
                                                                            &dyn Value))])
                                            });
                                    } else { ; }
                            };
                            match self.mark_retry(&querying.device_id).await? {
                                Connection::Connected => Ok(true),
                                Connection::Lost => Ok(self.publish().await.map(|_| true)?),
                            }
                        }
                    },
                None => Ok(false),
            }
        }
        async fn add_if_necessary(&self, discovered: Discovered)
            -> Result<bool> {
            let mut devices = self.devices.lock().await;
            let device_id = &discovered.device_id;
            if let Some(connected) = devices.get_mut(device_id) {
                    if connected.is_disconnected() && connected.retry.is_none()
                            {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                    {
                                        static META: ::tracing::Metadata<'static> =
                                            {
                                                ::tracing_core::metadata::Metadata::new("event src/nearby.rs:139",
                                                    "native::nearby", ::tracing::Level::INFO,
                                                    Some("src/nearby.rs"), Some(139u32), Some("native::nearby"),
                                                    ::tracing_core::field::FieldSet::new(&["message"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                    ::tracing::metadata::Kind::EVENT)
                                            };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                let enabled =
                                    ::tracing::Level::INFO <=
                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                            ::tracing::Level::INFO <=
                                                ::tracing::level_filters::LevelFilter::current() &&
                                        {
                                            let interest = CALLSITE.interest();
                                            !interest.is_never() &&
                                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                    interest)
                                        };
                                if enabled {
                                        (|value_set: ::tracing::field::ValueSet|
                                                    {
                                                        let meta = CALLSITE.metadata();
                                                        ::tracing::Event::dispatch(meta, &value_set);
                                                        ;
                                                    })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&format_args!("bg:discovered: {0:?}", connected) as
                                                                            &dyn Value))])
                                            });
                                    } else { ; }
                            };
                            connected.attempted = None;
                            connected.finished = None;
                        }
                    Ok(false)
                } else {
                   {
                       use ::tracing::__macro_support::Callsite as _;
                       static CALLSITE: ::tracing::callsite::DefaultCallsite =
                           {
                               static META: ::tracing::Metadata<'static> =
                                   {
                                       ::tracing_core::metadata::Metadata::new("event src/nearby.rs:147",
                                           "native::nearby", ::tracing::Level::INFO,
                                           Some("src/nearby.rs"), Some(147u32), Some("native::nearby"),
                                           ::tracing_core::field::FieldSet::new(&["message"],
                                               ::tracing_core::callsite::Identifier(&CALLSITE)),
                                           ::tracing::metadata::Kind::EVENT)
                                   };
                               ::tracing::callsite::DefaultCallsite::new(&META)
                           };
                       let enabled =
                           ::tracing::Level::INFO <=
                                       ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                   ::tracing::Level::INFO <=
                                       ::tracing::level_filters::LevelFilter::current() &&
                               {
                                   let interest = CALLSITE.interest();
                                   !interest.is_never() &&
                                       ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                           interest)
                               };
                       if enabled {
                               (|value_set: ::tracing::field::ValueSet|
                                           {
                                               let meta = CALLSITE.metadata();
                                               ::tracing::Event::dispatch(meta, &value_set);
                                               ;
                                           })({
                                       #[allow(unused_imports)]
                                       use ::tracing::field::{debug, display, Value};
                                       let mut iter = CALLSITE.metadata().fields().iter();
                                       CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                           Some(&format_args!("bg:discovered: {0:?}", discovered) as
                                                                   &dyn Value))])
                                   });
                           } else { ; }
                   };
                   devices.insert(device_id.clone(),
                       Querying {
                           device_id: device_id.clone(),
                           http_addr: {
                               let res =
                                   ::alloc::fmt::format(format_args!("{0}",
                                           discovered.http_addr.ok_or(::anyhow::__private::must_use({
                                                           let error =
                                                               ::anyhow::__private::format_err(format_args!("Expected HTTP addr"));
                                                           error
                                                       }))?));
                               res
                           },
                           busy: false,
                           discovered,
                           attempted: None,
                           finished: None,
                           retry: None,
                           failures: 0,
                       });
                   Ok(true)
               }
        }
        async fn first_station_to_query(&self) -> Result<Option<Querying>> {
            let mut devices = self.devices.lock().await;
            for (_, nearby) in devices.iter_mut() {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite =
                        {
                            static META: ::tracing::Metadata<'static> =
                                {
                                    ::tracing_core::metadata::Metadata::new("event src/nearby.rs:175",
                                        "native::nearby", ::tracing::Level::TRACE,
                                        Some("src/nearby.rs"), Some(175u32), Some("native::nearby"),
                                        ::tracing_core::field::FieldSet::new(&["message"],
                                            ::tracing_core::callsite::Identifier(&CALLSITE)),
                                        ::tracing::metadata::Kind::EVENT)
                                };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                    let enabled =
                        ::tracing::Level::TRACE <=
                                    ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                ::tracing::Level::TRACE <=
                                    ::tracing::level_filters::LevelFilter::current() &&
                            {
                                let interest = CALLSITE.interest();
                                !interest.is_never() &&
                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                        interest)
                            };
                    if enabled {
                            (|value_set: ::tracing::field::ValueSet|
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            ;
                                        })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = CALLSITE.metadata().fields().iter();
                                    CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&format_args!("{0:?}", nearby) as &dyn Value))])
                                });
                        } else { ; }
                };
                if nearby.should_query() {
                        nearby.attempted = Some(Utc::now());
                        nearby.finished = None;
                        nearby.retry = None;
                        return Ok(Some(nearby.clone()));
                    }
            }
            Ok(None)
        }
        async fn get_nearby_stations(&self) -> Result<Vec<NearbyStation>> {
            let devices = self.devices.lock().await;
            Ok(devices.values().filter(|q|
                                !q.is_disconnected()).map(|q|
                            NearbyStation {
                                device_id: q.device_id.0.to_string(),
                                busy: q.busy,
                            }).collect())
        }
        async fn publish(&self) -> Result<()> {
            let nearby = self.get_nearby_stations().await?;
            match self.publish_tx.send(BackgroundMessage::Domain(DomainMessage::NearbyStations(nearby))).await
                {
                Ok(_) => Ok(()),
                Err(e) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/nearby.rs:211",
                                            "native::nearby", ::tracing::Level::WARN,
                                            Some("src/nearby.rs"), Some(211u32), Some("native::nearby"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::WARN <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::WARN <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("Send NearbyStations failed: {0}", e) as
                                                                    &dyn Value))])
                                    });
                            } else { ; }
                    };
                    Ok(())
                }
            }
        }
        async fn mark_retry(&self, device_id: &DeviceId)
            -> Result<Connection> {
            let mut devices = self.devices.lock().await;
            let querying =
                devices.get_mut(device_id).expect("Whoa, no querying yet?");
            querying.failures += 1;
            if !querying.is_disconnected() {
                    querying.retry = Some(Utc::now() + Duration::seconds(1));
                }
            Ok((&*querying).into())
        }
        async fn mark_finished(&self, device_id: &DeviceId) -> Result<()> {
            let mut devices = self.devices.lock().await;
            let querying =
                devices.get_mut(device_id).expect("Whoa, no querying yet?");
            querying.finished = Some(Utc::now());
            querying.failures = 0;
            Ok(())
        }
        async fn mark_finished_and_publish_reply(&self, device_id: &DeviceId,
            status: RawAndDecoded<HttpReply>) -> Result<()> {
            self.mark_finished(device_id).await?;
            use base64::engine::general_purpose::STANDARD;
            self.publish_tx.send(BackgroundMessage::StationReply(device_id.clone(),
                            status.decoded, STANDARD.encode(status.bytes))).await?;
            Ok(())
        }
        async fn query_station(&self, querying: &Querying)
            -> Result<RawAndDecoded<HttpReply>> {
            let client = query::device::Client::new()?;
            Ok(client.query_readings(&querying.http_addr).await?)
        }
        pub async fn mark_busy(&self, device_id: &DeviceId, busy: bool)
            -> Result<()> {
            let mut devices = self.devices.lock().await;
            let querying =
                devices.get_mut(device_id).expect("Whoa, no querying yet?");
            querying.busy = busy;
            Ok(())
        }
        pub async fn mark_busy_and_publish(&self, device_id: &DeviceId,
            busy: bool) -> Result<()> {
            self.mark_busy(device_id, busy).await?;
            self.publish().await
        }
        pub async fn get_discovered(&self, device_id: &DeviceId)
            -> Option<Discovered> {
            let devices = self.devices.lock().await;
            let querying = devices.get(device_id);
            querying.map(|q| q.discovered.clone())
        }
        pub async fn handle_server_event(&self,
            publish_tx: Sender<BackgroundMessage>,
            last_progress: &mut Option<Instant>, event: ServerEvent)
            -> Result<()> {
            match &event {
                ServerEvent::Began(device_id) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/nearby.rs:288",
                                            "native::nearby", ::tracing::Level::INFO,
                                            Some("src/nearby.rs"), Some(288u32), Some("native::nearby"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::INFO <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::INFO <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("{0:?}", &event) as &dyn Value))])
                                    });
                            } else { ; }
                    };
                    self.mark_busy_and_publish(device_id, true).await?;
                    publish_tx.send(BackgroundMessage::Domain(DomainMessage::DownloadProgress(TransferProgress {
                                            device_id: device_id.0.to_owned(),
                                            status: TransferStatus::Starting,
                                        }))).await?;
                    Ok(())
                }
                ServerEvent::Transferring(device_id, started, progress) => {
                    let publish_progress =
                        match last_progress {
                            Some(last_progress) => {
                                tokio::time::Instant::now().sub(*last_progress) >
                                    std::time::Duration::from_millis(200)
                            }
                            None => true,
                        };
                    if publish_progress {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                    {
                                        static META: ::tracing::Metadata<'static> =
                                            {
                                                ::tracing_core::metadata::Metadata::new("event src/nearby.rs:311",
                                                    "native::nearby", ::tracing::Level::INFO,
                                                    Some("src/nearby.rs"), Some(311u32), Some("native::nearby"),
                                                    ::tracing_core::field::FieldSet::new(&["message"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                    ::tracing::metadata::Kind::EVENT)
                                            };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                let enabled =
                                    ::tracing::Level::INFO <=
                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                            ::tracing::Level::INFO <=
                                                ::tracing::level_filters::LevelFilter::current() &&
                                        {
                                            let interest = CALLSITE.interest();
                                            !interest.is_never() &&
                                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                    interest)
                                        };
                                if enabled {
                                        (|value_set: ::tracing::field::ValueSet|
                                                    {
                                                        let meta = CALLSITE.metadata();
                                                        ::tracing::Event::dispatch(meta, &value_set);
                                                        ;
                                                    })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&format_args!("{0:?}", &progress) as &dyn Value))])
                                            });
                                    } else { ; }
                            };
                            let total = progress.total.as_ref().unwrap();
                            publish_tx.send(BackgroundMessage::Domain(DomainMessage::DownloadProgress(TransferProgress {
                                                    device_id: device_id.0.to_owned(),
                                                    status: TransferStatus::Downloading(DownloadProgress {
                                                            started: started.duration_since(UNIX_EPOCH)?.as_millis() as
                                                                u64,
                                                            completed: total.completed,
                                                            total: total.total,
                                                            received: total.received,
                                                        }),
                                                }))).await?;
                            *last_progress = Some(Instant::now());
                        }
                    Ok(())
                }
                ServerEvent::Processing(device_id) => {
                    publish_tx.send(BackgroundMessage::Domain(DomainMessage::DownloadProgress(TransferProgress {
                                            device_id: device_id.0.to_owned(),
                                            status: TransferStatus::Processing,
                                        }))).await?;
                    Ok(())
                }
                ServerEvent::Completed(device_id) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/nearby.rs:345",
                                            "native::nearby", ::tracing::Level::INFO,
                                            Some("src/nearby.rs"), Some(345u32), Some("native::nearby"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::INFO <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::INFO <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("{0:?}", &event) as &dyn Value))])
                                    });
                            } else { ; }
                    };
                    self.mark_busy_and_publish(device_id, false).await?;
                    publish_tx.send(BackgroundMessage::Domain(DomainMessage::DownloadProgress(TransferProgress {
                                            device_id: device_id.0.to_owned(),
                                            status: TransferStatus::Completed,
                                        }))).await?;
                    Ok(())
                }
                ServerEvent::Failed(device_id) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/nearby.rs:359",
                                            "native::nearby", ::tracing::Level::INFO,
                                            Some("src/nearby.rs"), Some(359u32), Some("native::nearby"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::INFO <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::INFO <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("{0:?}", &event) as &dyn Value))])
                                    });
                            } else { ; }
                    };
                    self.mark_busy_and_publish(device_id, false).await?;
                    publish_tx.send(BackgroundMessage::Domain(DomainMessage::DownloadProgress(TransferProgress {
                                            device_id: device_id.0.to_owned(),
                                            status: TransferStatus::Failed,
                                        }))).await?;
                    Ok(())
                }
                ServerEvent::Available(files) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/nearby.rs:373",
                                            "native::nearby", ::tracing::Level::INFO,
                                            Some("src/nearby.rs"), Some(373u32), Some("native::nearby"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::INFO <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::INFO <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE.metadata().fields().value_set(&[(&iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&format_args!("{0:?}", files) as &dyn Value))])
                                    });
                            } else { ; }
                    };
                    let files =
                        files.iter().map(|f|
                                    RecordArchive {
                                        device_id: f.device_id.clone(),
                                        path: f.path.clone(),
                                    }).collect();
                    publish_tx.send(BackgroundMessage::Domain(DomainMessage::RecordArchives(files))).await?;
                    Ok(())
                }
            }
        }
    }
    type ModelTime = DateTime<Utc>;
    struct Querying {
        pub device_id: DeviceId,
        pub http_addr: String,
        pub discovered: Discovered,
        pub busy: bool,
        pub attempted: Option<ModelTime>,
        pub finished: Option<ModelTime>,
        pub retry: Option<ModelTime>,
        pub failures: i32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Querying {
        #[inline]
        fn clone(&self) -> Querying {
            Querying {
                device_id: ::core::clone::Clone::clone(&self.device_id),
                http_addr: ::core::clone::Clone::clone(&self.http_addr),
                discovered: ::core::clone::Clone::clone(&self.discovered),
                busy: ::core::clone::Clone::clone(&self.busy),
                attempted: ::core::clone::Clone::clone(&self.attempted),
                finished: ::core::clone::Clone::clone(&self.finished),
                retry: ::core::clone::Clone::clone(&self.retry),
                failures: ::core::clone::Clone::clone(&self.failures),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Querying {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ =
                &["device_id", "http_addr", "discovered", "busy", "attempted",
                            "finished", "retry", "failures"];
            let values: &[&dyn ::core::fmt::Debug] =
                &[&self.device_id, &self.http_addr, &self.discovered,
                            &self.busy, &self.attempted, &self.finished, &self.retry,
                            &&self.failures];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Querying",
                names, values)
        }
    }
    impl Querying {
        fn should_query(&self) -> bool {
            if self.busy { return false; }
            let now = Utc::now();
            match self.attempted {
                Some(attempted) => {
                    if now - attempted > Duration::seconds(10) {
                            true
                        } else {
                           match self.retry {
                               Some(retry) => { if now >= retry { true } else { false } }
                               None => false,
                           }
                       }
                }
                None => true,
            }
        }
        fn is_disconnected(&self) -> bool { self.failures >= 3 }
    }
    pub enum Connection { Connected, Lost, }
    #[automatically_derived]
    impl ::core::clone::Clone for Connection {
        #[inline]
        fn clone(&self) -> Connection {
            match self {
                Connection::Connected => Connection::Connected,
                Connection::Lost => Connection::Lost,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Connection {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f,
                match self {
                    Connection::Connected => "Connected",
                    Connection::Lost => "Lost",
                })
        }
    }
    impl Into<Connection> for &Querying {
        fn into(self) -> Connection {
            if self.is_disconnected() {
                    Connection::Lost
                } else { Connection::Connected }
        }
    }
}
 stderr=    Updating crates.io index
 Downloading crates ...
  Downloaded flutter_rust_bridge_macros v1.82.1
  Downloaded flutter_rust_bridge v1.82.1
    Checking cfg-if v1.0.0
    Checking once_cell v1.18.0
    Checking pin-project-lite v0.2.13
    Checking smallvec v1.11.1
    Checking scopeguard v1.2.0
    Checking bytes v1.5.0
    Checking libc v0.2.148
    Checking futures-core v0.3.28
    Checking memchr v2.6.3
    Checking futures-sink v0.3.28
   Compiling tracing-attributes v0.1.26
    Checking itoa v1.0.9
   Compiling serde_derive v1.0.188
    Checking lock_api v0.4.10
    Checking slab v0.4.9
    Checking futures-task v0.3.28
    Checking futures-channel v0.3.28
   Compiling futures-macro v0.3.28
    Checking tracing-core v0.1.31
    Checking futures-io v0.3.28
    Checking log v0.4.20
    Checking pin-utils v0.1.0
    Checking spin v0.5.2
    Checking untrusted v0.7.1
    Checking adler v1.0.2
    Checking ahash v0.8.3
    Checking num-traits v0.2.16
    Checking miniz_oxide v0.7.1
    Checking fnv v1.0.7
    Checking allocator-api2 v0.2.16
    Checking anyhow v1.0.75
    Checking http v0.2.9
    Checking hashbrown v0.12.3
    Checking ppv-lite86 v0.2.17
    Checking tinyvec_macros v0.1.1
    Checking ryu v1.0.15
    Checking tinyvec v1.6.0
    Checking parking_lot_core v0.9.8
    Checking num_cpus v1.16.0
    Checking mio v0.8.8
    Checking parking_lot v0.12.1
    Checking socket2 v0.5.4
    Checking signal-hook-registry v1.4.1
    Checking ring v0.16.20
    Checking getrandom v0.2.10
    Checking hashbrown v0.14.0
    Checking socket2 v0.4.9
    Checking rand_core v0.6.4
    Checking indexmap v1.9.3
    Checking tokio v1.32.0
   Compiling thiserror-impl v1.0.48
    Checking rand_chacha v0.3.1
    Checking percent-encoding v2.3.0
    Checking try-lock v0.2.4
    Checking iana-time-zone v0.1.57
    Checking rand v0.8.5
    Checking form_urlencoded v1.2.0
    Checking want v0.3.1
   Compiling prost-derive v0.11.9
    Checking unicode-normalization v0.1.22
    Checking http-body v0.4.5
    Checking crc32fast v1.3.2
    Checking httparse v1.8.0
   Compiling miette-derive v5.10.0
    Checking lazy_static v1.4.0
    Checking unicode-bidi v0.3.13
    Checking httpdate v1.0.3
    Checking futures-util v0.3.28
    Checking bitflags v1.3.2
    Checking unicode-width v0.1.11
    Checking tower-service v0.3.2
    Checking idna v0.4.0
    Checking raw-cpuid v10.7.0
    Checking flate2 v1.0.27
    Checking crossbeam-utils v0.8.16
    Checking sct v0.7.0
    Checking rustls-webpki v0.101.6
   Compiling libsqlite3-sys v0.26.0
   Compiling backtrace v0.3.69
    Checking either v1.9.0
    Checking tracing v0.1.37
    Checking base64 v0.21.4
    Checking gimli v0.28.0
    Checking rustls v0.21.7
    Checking url v2.4.1
    Checking rustls-pemfile v1.0.3
   Compiling async-trait v0.1.73
    Checking quanta v0.9.3
    Checking thiserror v1.0.48
    Checking dashmap v5.5.3
    Checking hashlink v0.8.4
    Checking object v0.32.1
    Checking encoding_rs v0.8.33
   Compiling async-stream-impl v0.3.5
    Checking miette v5.10.0
    Checking regex-syntax v0.6.29
    Checking prost v0.11.9
    Checking mime v0.3.17
    Checking fallible-streaming-iterator v0.1.9
    Checking no-std-compat v0.4.1
    Checking nonzero_ext v0.3.0
    Checking ipnet v2.8.0
    Checking webpki-roots v0.25.2
    Checking bit_utils v0.1.1
    Checking byteorder v1.4.3
    Checking hex v0.4.3
    Checking futures-timer v3.0.2
    Checking bitflags v2.4.0
    Checking futures-executor v0.3.28
    Checking addr2line v0.21.0
    Checking futures v0.3.28
    Checking rustc-demangle v0.1.23
    Checking regex-syntax v0.7.5
    Checking fallible-iterator v0.2.0
    Checking governor v0.5.1
   Compiling flutter_rust_bridge v1.82.1
    Checking quick-protobuf v0.8.1
    Checking varint v0.9.0
    Checking async-stream v0.3.5
    Checking num-integer v0.1.45
    Checking itertools v0.10.5
    Checking instant v0.1.12
    Checking atomic v0.5.3
    Checking gen_ops v0.4.0
    Checking overload v0.1.1
    Checking dart-sys v4.0.2
    Checking serde v1.0.188
    Checking nu-ansi-term v0.46.0
    Checking sharded-slab v0.1.4
    Checking tracing-log v0.1.3
    Checking threadpool v1.8.1
    Checking thread_local v1.1.7
    Checking tokio-util v0.7.9
    Checking tokio-rustls v0.24.1
    Checking async-compression v0.4.3
    Checking discovery v0.1.0 (/home/kate/Documents/GitLab/patina/rustfk/libs/discovery)
    Checking backoff v0.4.0
    Checking bytemuck v1.14.0
    Checking glob v0.3.1
   Compiling flutter_rust_bridge_macros v1.82.1
    Checking itertools v0.11.0
    Checking regex-automata v0.1.10
    Checking h2 v0.3.21
    Checking tokio-stream v0.1.14
    Checking regex-automata v0.3.8
    Checking range-set-blaze v0.1.9
    Checking matchers v0.1.0
    Checking chrono v0.4.31
    Checking serde_json v1.0.107
    Checking serde_urlencoded v0.7.1
    Checking regex v1.9.5
    Checking tracing-subscriber v0.3.17
    Checking protos v0.1.0 (/home/kate/Documents/GitLab/patina/rustfk/libs/protos)
    Checking hyper v0.14.27
    Checking allo-isolate v0.1.20
    Checking sync v0.1.0 (/home/kate/Documents/GitLab/patina/rustfk/libs/sync)
    Checking rusqlite v0.29.0
    Checking rusqlite_migration v1.0.2
    Checking hyper-rustls v0.24.1
    Checking reqwest v0.11.20
    Checking query v0.1.0 (/home/kate/Documents/GitLab/patina/rustfk/libs/query)
warning: private item shadows public glob re-export
  --> /home/kate/Documents/GitLab/patina/rustfk/libs/query/src/device.rs:10:5
   |
10 | use tokio::fs::File;
   |     ^^^^^^^^^^^^^^^
   |
note: the name `File` in the type namespace is supposed to be publicly re-exported here
  --> /home/kate/Documents/GitLab/patina/rustfk/libs/query/src/device.rs:15:9
   |
15 | pub use protos::http::*;
   |         ^^^^^^^^^^^^^^^
note: but the private item here shadows it
  --> /home/kate/Documents/GitLab/patina/rustfk/libs/query/src/device.rs:10:5
   |
10 | use tokio::fs::File;
   |     ^^^^^^^^^^^^^^^
   = note: `#[warn(hidden_glob_reexports)]` on by default
warning: use of deprecated associated function `chrono::DateTime::<Tz>::from_utc`: Use TimeZone::from_utc_datetime() or DateTime::from_naive_utc_and_offset instead
   --> /home/kate/Documents/GitLab/patina/rustfk/libs/query/src/portal.rs:205:36
    |
205 |                 .map(|v| DateTime::from_utc(v, Utc))
    |                                    ^^^^^^^^
    |
    = note: `#[warn(deprecated)]` on by default
    Checking store v0.1.0 (/home/kate/Documents/GitLab/patina/rustfk/libs/store)
    Checking native v0.1.0 (/home/kate/Documents/GitLab/patina/native)
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:23:12
   |
23 | use crate::logging::api::AddOrUpdatePortalStation;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:24:12
   |
24 | use crate::logging::api::Authenticated;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:25:12
   |
25 | use crate::logging::api::BatteryInfo;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:26:12
   |
26 | use crate::logging::api::DeviceCapabilities;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:27:12
   |
27 | use crate::logging::api::DomainMessage;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:28:12
   |
28 | use crate::logging::api::DownloadProgress;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:29:12
   |
29 | use crate::logging::api::EphemeralConfig;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:30:12
   |
30 | use crate::logging::api::FirmwareDownloadStatus;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:31:12
   |
31 | use crate::logging::api::FirmwareInfo;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:32:12
   |
32 | use crate::logging::api::LocalFirmware;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:33:12
   |
33 | use crate::logging::api::ModuleConfig;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:34:12
   |
34 | use crate::logging::api::NearbyStation;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:35:12
   |
35 | use crate::logging::api::NetworkConfig;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:36:12
   |
36 | use crate::logging::api::RecordArchive;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:37:12
   |
37 | use crate::logging::api::SensorConfig;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:38:12
   |
38 | use crate::logging::api::SensorValue;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:39:12
   |
39 | use crate::logging::api::SolarInfo;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:40:12
   |
40 | use crate::logging::api::StationConfig;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:41:12
   |
41 | use crate::logging::api::StreamInfo;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:42:12
   |
42 | use crate::logging::api::Tokens;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:43:12
   |
43 | use crate::logging::api::TransferProgress;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:44:12
   |
44 | use crate::logging::api::TransferStatus;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:45:12
   |
45 | use crate::logging::api::TransmissionConfig;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:46:12
   |
46 | use crate::logging::api::TransmissionToken;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:47:12
   |
47 | use crate::logging::api::UpgradeProgress;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:48:12
   |
48 | use crate::logging::api::UpgradeStatus;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:49:12
   |
49 | use crate::logging::api::UploadProgress;
   |            ^^^^^^^ could not find `logging` in the crate root
error[E0433]: failed to resolve: could not find `logging` in the crate root
  --> src/bridge_generated.rs:50:12
   |
50 | use crate::logging::api::WifiTransmissionConfig;
   |            ^^^^^^^ could not find `logging` in the crate root
For more information about this error, try `rustc --explain E0433`.
error: could not compile `native` (lib) due to 28 previous errors


2023/09/25 13:29:16 [[34mDEBUG[0m] Trying to parse "/home/kate/Documents/GitLab/patina/native/src/api.rs"
2023/09/25 13:29:16 [[34mDEBUG[0m] Trying to parse "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.rs"
2023/09/25 13:29:16 [[34mDEBUG[0m] Trying to parse "/home/kate/Documents/GitLab/patina/native/src/firmware.rs"
2023/09/25 13:29:16 [[34mDEBUG[0m] Trying to parse "/home/kate/Documents/GitLab/patina/native/src/nearby.rs"
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(start_native)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(get_my_stations)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(authenticate_portal)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(add_or_update_station_in_portal)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(configure_wifi_transmission)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(clear_calibration)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(calibrate)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(validate_tokens)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(start_download)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(start_upload)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(cache_firmware)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(upgrade_station)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(rust_release_mode)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(create_log_sink)
2023/09/25 13:29:16 [[32mINFO[0m] Phase: Validate config(s)
2023/09/25 13:29:16 [[32mINFO[0m] Picked config: Opts { rust_input_path: "/home/kate/Documents/GitLab/patina/native/src/api.rs", dart_output_path: "/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.dart", dart_decl_output_path: Some("/home/kate/Documents/GitLab/patina/lib/gen/bridge_definitions.dart"), c_output_path: ["/home/kate/Documents/GitLab/patina/macos/Runner/bridge_generated.h", "ios/Runner/bridge_generated.h"], rust_crate_dir: "/home/kate/Documents/GitLab/patina/native", rust_output_path: "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.rs", class_name: "Native", dart_format_line_length: 80, dart_enums_style: false, skip_add_mod_to_lib: false, llvm_path: ["/opt/homebrew/opt/llvm", "/usr/local/opt/llvm", "/usr/lib/llvm-9", "/usr/lib/llvm-10", "/usr/lib/llvm-11", "/usr/lib/llvm-12", "/usr/lib/llvm-13", "/usr/lib/llvm-14", "/usr/lib/", "/usr/lib64/", "C:/Program Files/llvm", "C:/msys64/mingw64"], llvm_compiler_opts: "", manifest_path: "/home/kate/Documents/GitLab/patina/native/Cargo.toml", dart_root: Some("/home/kate/Documents/GitLab/patina"), build_runner: true, block_index: BlockIndex(0), skip_deps_check: false, wasm_enabled: true, inline_rust: false, bridge_in_method: true, extra_headers: "", dart3: true, keep_going: false }
2023/09/25 13:29:16 [[32mINFO[0m] Phase: Parse source code to AST, then to IR
2023/09/25 13:29:16 [[34mDEBUG[0m] Trying to parse "/home/kate/Documents/GitLab/patina/native/src/api.rs"
2023/09/25 13:29:16 [[34mDEBUG[0m] Trying to parse "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.rs"
2023/09/25 13:29:16 [[34mDEBUG[0m] Trying to parse "/home/kate/Documents/GitLab/patina/native/src/firmware.rs"
2023/09/25 13:29:16 [[34mDEBUG[0m] Trying to parse "/home/kate/Documents/GitLab/patina/native/src/nearby.rs"
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(start_native)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(get_my_stations)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(authenticate_portal)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(add_or_update_station_in_portal)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(configure_wifi_transmission)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(clear_calibration)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(calibrate)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(validate_tokens)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(start_download)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(start_upload)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(cache_firmware)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(upgrade_station)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(rust_release_mode)
2023/09/25 13:29:16 [[34mDEBUG[0m] parse_function function name: Ident(create_log_sink)
2023/09/25 13:29:16 [[32mINFO[0m] Phase: Transform IR
2023/09/25 13:29:16 [[34mDEBUG[0m] transform_func_input_add_boxed wrap Boxed to field=IrField { ty: StructRef(IrTypeStructRef { name: "Tokens", freezed: false, empty: false, is_exception: false }), name: IrIdent { raw: "tokens" }, is_final: true, comments: [], default: None, settings: IrFieldSettings { is_in_mirrored_enum: false } }
2023/09/25 13:29:16 [[34mDEBUG[0m] transform_func_input_add_boxed wrap Boxed to field=IrField { ty: StructRef(IrTypeStructRef { name: "AddOrUpdatePortalStation", freezed: false, empty: false, is_exception: false }), name: IrIdent { raw: "station" }, is_final: true, comments: [], default: None, settings: IrFieldSettings { is_in_mirrored_enum: false } }
2023/09/25 13:29:16 [[34mDEBUG[0m] transform_func_input_add_boxed wrap Boxed to field=IrField { ty: StructRef(IrTypeStructRef { name: "WifiTransmissionConfig", freezed: false, empty: false, is_exception: false }), name: IrIdent { raw: "config" }, is_final: true, comments: [], default: None, settings: IrFieldSettings { is_in_mirrored_enum: false } }
2023/09/25 13:29:16 [[34mDEBUG[0m] transform_func_input_add_boxed wrap Boxed to field=IrField { ty: StructRef(IrTypeStructRef { name: "Tokens", freezed: false, empty: false, is_exception: false }), name: IrIdent { raw: "tokens" }, is_final: true, comments: [], default: None, settings: IrFieldSettings { is_in_mirrored_enum: false } }
2023/09/25 13:29:16 [[34mDEBUG[0m] transform_func_input_add_boxed wrap Boxed to field=IrField { ty: StructRef(IrTypeStructRef { name: "Tokens", freezed: false, empty: false, is_exception: false }), name: IrIdent { raw: "tokens" }, is_final: true, comments: [], default: None, settings: IrFieldSettings { is_in_mirrored_enum: false } }
2023/09/25 13:29:16 [[34mDEBUG[0m] transform_func_input_add_boxed wrap Boxed to field=IrField { ty: StructRef(IrTypeStructRef { name: "LocalFirmware", freezed: false, empty: false, is_exception: false }), name: IrIdent { raw: "firmware" }, is_final: true, comments: [], default: None, settings: IrFieldSettings { is_in_mirrored_enum: false } }
2023/09/25 13:29:16 [[32mINFO[0m] Phase: Generate Rust code
2023/09/25 13:29:16 [[34mDEBUG[0m] execute format_rust path=["/home/kate/Documents/GitLab/patina/native/src/bridge_generated.rs", "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.io.rs", "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.web.rs"]
2023/09/25 13:29:16 [[34mDEBUG[0m] execute command: bin=rustfmt args="/home/kate/Documents/GitLab/patina/native/src/bridge_generated.rs /home/kate/Documents/GitLab/patina/native/src/bridge_generated.io.rs /home/kate/Documents/GitLab/patina/native/src/bridge_generated.web.rs" current_dir=None cmd="rustfmt" "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.rs" "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.io.rs" "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.web.rs"
2023/09/25 13:29:16 [[34mDEBUG[0m] command="rustfmt" "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.rs" "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.io.rs" "/home/kate/Documents/GitLab/patina/native/src/bridge_generated.web.rs" stdout= stderr=
2023/09/25 13:29:16 [[32mINFO[0m] Phase: Generate Dart code
2023/09/25 13:29:16 [[34mDEBUG[0m] Guessing toolchain the runner is run into
2023/09/25 13:29:16 [[34mDEBUG[0m] execute command: bin=sh args="-c \"flutter\" \"--version\"" current_dir=None cmd="sh" "-c" "\"flutter\" \"--version\""
2023/09/25 13:29:16 [[34mDEBUG[0m] command="sh" "-c" "\"flutter\" \"--version\"" stdout=Flutter 3.13.0 • channel stable • https://github.com/flutter/flutter.git
Framework • revision efbf63d9c6 (6 weeks ago) • 2023-08-15 21:05:06 -0500
Engine • revision 1ac611c64e
Tools • Dart 3.1.0 • DevTools 2.25.0
 stderr=
2023/09/25 13:29:16 [[34mDEBUG[0m] Checking presence of ffi in dependencies at /home/kate/Documents/GitLab/patina
2023/09/25 13:29:16 [[34mDEBUG[0m] Checking presence of ffi in dependencies at /home/kate/Documents/GitLab/patina
2023/09/25 13:29:16 [[34mDEBUG[0m] Checking presence of ffigen in dev_dependencies at /home/kate/Documents/GitLab/patina
2023/09/25 13:29:16 [[34mDEBUG[0m] Checking presence of ffigen in dev_dependencies at /home/kate/Documents/GitLab/patina
2023/09/25 13:29:16 [[32mINFO[0m] Phase: Generating Dart bindings for Rust
2023/09/25 13:29:16 [[34mDEBUG[0m] execute cbindgen rust_crate_dir=/home/kate/Documents/GitLab/patina/native c_output_path=/tmp/.tmpm8b9GP.h
2023/09/25 13:29:16 [[34mDEBUG[0m] cbindgen config: Config {
    header: None,
    includes: [],
    sys_includes: [
        "stdbool.h",
        "stdint.h",
        "stdlib.h",
    ],
    after_includes: Some(
        "typedef struct _Dart_Handle* Dart_Handle;",
    ),
    trailer: None,
    include_guard: None,
    pragma_once: false,
    no_includes: true,
    autogen_warning: None,
    include_version: false,
    namespace: None,
    namespaces: None,
    using_namespaces: None,
    braces: SameLine,
    line_length: 100,
    tab_width: 2,
    line_endings: LF,
    language: C,
    cpp_compat: false,
    style: Both,
    sort_by: None,
    usize_is_size_t: false,
    parse: ParseConfig {
        parse_deps: false,
        include: None,
        exclude: [],
        expand: ParseExpandConfig {
            crates: [],
            all_features: false,
            default_features: true,
            features: None,
            profile: Debug,
        },
        clean: false,
        extra_bindings: [],
    },
    export: ExportConfig {
        include: [
            "\"wire_AddOrUpdatePortalStation\"",
            "\"wire_Authenticated\"",
            "\"wire_BatteryInfo\"",
            "\"wire_DeviceCapabilities\"",
            "\"wire_DownloadProgress\"",
            "\"wire_EphemeralConfig\"",
            "\"wire_FirmwareInfo\"",
            "\"wire_LocalFirmware\"",
            "\"wire_ModuleConfig\"",
            "\"wire_NearbyStation\"",
            "\"wire_NetworkConfig\"",
            "\"wire_RecordArchive\"",
            "\"wire_SensorConfig\"",
            "\"wire_SensorValue\"",
            "\"wire_SolarInfo\"",
            "\"wire_StationConfig\"",
            "\"wire_StreamInfo\"",
            "\"wire_Tokens\"",
            "\"wire_TransferProgress\"",
            "\"wire_TransmissionConfig\"",
            "\"wire_TransmissionToken\"",
            "\"wire_UpgradeProgress\"",
            "\"wire_UploadProgress\"",
            "\"wire_WifiTransmissionConfig\"",
        ],
        exclude: [],
        rename: {},
        pre_body: {},
        body: {},
        prefix: None,
        item_types: [],
        renaming_overrides_prefixing: false,
        mangle: MangleConfig {
            rename_types: None,
            remove_underscores: false,
        },
    },
    macro_expansion: MacroExpansionConfig {
        bitflags: false,
    },
    layout: LayoutConfig {
        packed: None,
        aligned_n: None,
    },
    function: FunctionConfig {
        prefix: None,
        postfix: None,
        must_use: None,
        args: Auto,
        rename_args: None,
        swift_name_macro: None,
        sort_by: None,
        no_return: None,
    },
    structure: StructConfig {
        rename_fields: None,
        derive_constructor: false,
        derive_eq: false,
        derive_neq: false,
        derive_lt: false,
        derive_lte: false,
        derive_gt: false,
        derive_gte: false,
        derive_ostream: false,
        associated_constants_in_body: false,
        must_use: None,
    },
    enumeration: EnumConfig {
        rename_variants: None,
        rename_variant_name_fields: SnakeCase,
        add_sentinel: false,
        prefix_with_name: false,
        derive_helper_methods: false,
        derive_const_casts: false,
        derive_mut_casts: false,
        cast_assert_name: None,
        must_use: None,
        derive_tagged_enum_destructor: false,
        derive_tagged_enum_copy_constructor: false,
        derive_tagged_enum_copy_assignment: false,
        derive_ostream: false,
        enum_class: true,
        private_default_tagged_enum_constructor: false,
    },
    constant: ConstantConfig {
        allow_static_const: true,
        allow_constexpr: true,
        sort_by: None,
    },
    defines: {},
    documentation: true,
    documentation_style: Auto,
    documentation_length: Full,
    pointer: PtrConfig {
        non_null_attribute: None,
    },
    only_target_dependencies: false,
    cython: CythonConfig {
        header: None,
        cimports: {},
    },
}
2023/09/25 13:29:16 [[34mDEBUG[0m] Parsing crate native
2023/09/25 13:29:16 [[33mWARN[0m] Skip native::SDK - (not `pub`).
2023/09/25 13:29:16 [[33mWARN[0m] Skip native::SDK - (not `no_mangle`).
2023/09/25 13:29:16 [[33mWARN[0m] Skip native::RUNTIME - (not `pub`).
2023/09/25 13:29:16 [[33mWARN[0m] Skip native::RUNTIME - (not `no_mangle`).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::MergeAndPublishReplies - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::Sdk - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::LogSink - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::WifiTransmissionConfig - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::AddOrUpdatePortalStation - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::Tokens - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::TransmissionToken - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::Authenticated - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::DownloadProgress - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::UploadProgress - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::TransferStatus - opaque (Enum is not marked with a valid #[repr(prim)] or #[repr(C)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::FirmwareDownloadStatus - opaque (Enum is not marked with a valid #[repr(prim)] or #[repr(C)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::UpgradeStatus - opaque (Enum is not marked with a valid #[repr(prim)] or #[repr(C)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::UpgradeProgress - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::TransferProgress - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::RecordArchive - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::DomainMessage - opaque (Enum is not marked with a valid #[repr(prim)] or #[repr(C)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::LocalFirmware - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::StreamInfo - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::BatteryInfo - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::SolarInfo - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::StationConfig - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::CapabilitiesInfo - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::FirmwareInfo - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::ModuleConfig - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::SensorConfig - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::SensorValue - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::NearbyStation - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::EphemeralConfig - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::DeviceCapabilities - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::NetworkConfig - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::TransmissionConfig - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::StationAndConnection - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::SdkMappingError - opaque (Enum is not marked with a valid #[repr(prim)] or #[repr(C)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::DartPort.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::DartPostCObjectFnType.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::store_dart_post_cobject.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::get_dart_object.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::drop_dart_object.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::new_dart_opaque.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::init_frb_dart_api_dl.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::DartCObject - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::WireSyncReturn.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_start_native.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_get_my_stations.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_authenticate_portal.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_add_or_update_station_in_portal.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_configure_wifi_transmission.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_clear_calibration.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_calibrate.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_validate_tokens.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_start_download.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_start_upload.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_cache_firmware.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_upgrade_station.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_rust_release_mode.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_create_log_sink.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::new_box_autoadd_add_or_update_portal_station_0.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::new_box_autoadd_local_firmware_0.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::new_box_autoadd_tokens_0.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::new_box_autoadd_wifi_transmission_config_0.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::new_list_record_archive_0.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::new_uint_8_list_0.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_AddOrUpdatePortalStation.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_list_record_archive.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_LocalFirmware.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_RecordArchive.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_Tokens.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_TransmissionToken.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_uint_8_list.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::wire_WifiTransmissionConfig.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::free_WireSyncReturn.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::CheckForAndCacheFirmware - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::FirmwareUpgrader - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::BackgroundMessage - opaque (Enum is not marked with a valid #[repr(prim)] or #[repr(C)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::NearbyDevices - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[33mWARN[0m] Skip native::ONE_SECOND - (not `pub`).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::ModelTime.
2023/09/25 13:29:16 [[32mINFO[0m] Take native::Querying - opaque (Struct is not marked #[repr(C)] or #[repr(transparent)].).
2023/09/25 13:29:16 [[32mINFO[0m] Take native::Connection - opaque (Enum is not marked with a valid #[repr(prim)] or #[repr(C)].).
2023/09/25 13:29:16 [[33mWARN[0m] Cannot find a mangling for generic path GenericPath { path: Path { name: "DateTime" }, export_name: "DateTime", generics: [Type(Path(GenericPath { path: Path { name: "Utc" }, export_name: "Utc", generics: [], ctype: None }))], ctype: None }. This usually means that a type referenced by this generic was incompatible or not found.
2023/09/25 13:29:16 [[33mWARN[0m] Can't find Dart_Handle. This usually means that this type was incompatible or not found.
2023/09/25 13:29:16 [[33mWARN[0m] Can't find Dart_Handle. This usually means that this type was incompatible or not found.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[33mWARN[0m] Missing `[defines]` entry for `target_family = "wasm"` in cbindgen config.
2023/09/25 13:29:16 [[34mDEBUG[0m] execute ffigen c_path=/tmp/.tmpm8b9GP.h dart_path=/tmp/.tmpb4jMhG llvm_path=["/opt/homebrew/opt/llvm", "/usr/local/opt/llvm", "/usr/lib/llvm-9", "/usr/lib/llvm-10", "/usr/lib/llvm-11", "/usr/lib/llvm-12", "/usr/lib/llvm-13", "/usr/lib/llvm-14", "/usr/lib/", "/usr/lib64/", "C:/Program Files/llvm", "C:/msys64/mingw64"]
2023/09/25 13:29:16 [[34mDEBUG[0m] ffigen config: 
        output: '/tmp/.tmpb4jMhG'
        name: 'NativeWire'
        description: 'generated by flutter_rust_bridge'
        headers:
          entry-points:
            - '/tmp/.tmpm8b9GP.h'
          include-directives:
            - '/tmp/.tmpm8b9GP.h'
        comments: false
        preamble: |
          // ignore_for_file: camel_case_types, non_constant_identifier_names, avoid_positional_boolean_parameters, annotate_overrides, constant_identifier_names
        
        llvm-path:
           - '/opt/homebrew/opt/llvm'
           - '/usr/local/opt/llvm'
           - '/usr/lib/llvm-9'
           - '/usr/lib/llvm-10'
           - '/usr/lib/llvm-11'
           - '/usr/lib/llvm-12'
           - '/usr/lib/llvm-13'
           - '/usr/lib/llvm-14'
           - '/usr/lib/'
           - '/usr/lib64/'
           - 'C:/Program Files/llvm'
           - 'C:/msys64/mingw64'

2023/09/25 13:29:16 [[34mDEBUG[0m] ffigen config_file: NamedTempFile("/tmp/.tmpVEmHS7")
2023/09/25 13:29:16 [[34mDEBUG[0m] Guessing toolchain the runner is run into
2023/09/25 13:29:16 [[34mDEBUG[0m] execute command: bin=sh args="-c \"flutter\" \"pub\" \"run\" \"ffigen\" \"--config\" \"/tmp/.tmpVEmHS7\"" current_dir=Some("/home/kate/Documents/GitLab/patina") cmd=cd "/home/kate/Documents/GitLab/patina" && "sh" "-c" "\"flutter\" \"pub\" \"run\" \"ffigen\" \"--config\" \"/tmp/.tmpVEmHS7\""
2023/09/25 13:29:19 [[34mDEBUG[0m] command=cd "/home/kate/Documents/GitLab/patina" && "sh" "-c" "\"flutter\" \"pub\" \"run\" \"ffigen\" \"--config\" \"/tmp/.tmpVEmHS7\"" stdout=Running in Directory: '/home/kate/Documents/GitLab/patina'
Input Headers: [/tmp/.tmpm8b9GP.h]
[WARNING]: No definition found for declaration - (Cursor) spelling: _Dart_Handle, kind: 2, kindSpelling: StructDecl, type: 105, typeSpelling: struct _Dart_Handle, usr: c:@S@_Dart_Handle
[WARNING]: No definition found for declaration - (Cursor) spelling: _Dart_Handle, kind: 2, kindSpelling: StructDecl, type: 105, typeSpelling: struct _Dart_Handle, usr: c:@S@_Dart_Handle
[WARNING]: No definition found for declaration - (Cursor) spelling: DartCObject, kind: 2, kindSpelling: StructDecl, type: 105, typeSpelling: struct DartCObject, usr: c:@S@DartCObject
[WARNING]: No definition found for declaration - (Cursor) spelling: DartCObject, kind: 2, kindSpelling: StructDecl, type: 105, typeSpelling: struct DartCObject, usr: c:@S@DartCObject
[WARNING]: No definition found for declaration - (Cursor) spelling: _Dart_Handle, kind: 2, kindSpelling: StructDecl, type: 105, typeSpelling: struct _Dart_Handle, usr: c:@S@_Dart_Handle
[WARNING]: No definition found for declaration - (Cursor) spelling: _Dart_Handle, kind: 2, kindSpelling: StructDecl, type: 105, typeSpelling: struct _Dart_Handle, usr: c:@S@_Dart_Handle
[WARNING]: No definition found for declaration - (Cursor) spelling: _Dart_Handle, kind: 2, kindSpelling: StructDecl, type: 105, typeSpelling: struct _Dart_Handle, usr: c:@S@_Dart_Handle
[WARNING]: No definition found for declaration - (Cursor) spelling: _Dart_Handle, kind: 2, kindSpelling: StructDecl, type: 105, typeSpelling: struct _Dart_Handle, usr: c:@S@_Dart_Handle
[WARNING]: No definition found for declaration - (Cursor) spelling: DartCObject, kind: 2, kindSpelling: StructDecl, type: 105, typeSpelling: struct DartCObject, usr: c:@S@DartCObject
[WARNING]: Generated declaration '_Dart_Handle' start's with '_' and therefore will be private.
Finished, Bindings generated in /tmp/.tmpb4jMhG
 stderr=
2023/09/25 13:29:19 [[34mDEBUG[0m] distinct_input_types=[Delegate(String), StructRef(IrTypeStructRef { name: "AddOrUpdatePortalStation", freezed: false, empty: false, is_exception: false }), Primitive(Bool), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "AddOrUpdatePortalStation", freezed: false, empty: false, is_exception: false }) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "LocalFirmware", freezed: false, empty: false, is_exception: false }) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "Tokens", freezed: false, empty: false, is_exception: false }) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "WifiTransmissionConfig", freezed: false, empty: false, is_exception: false }) }), Primitive(I64), GeneralList(IrTypeGeneralList { inner: StructRef(IrTypeStructRef { name: "RecordArchive", freezed: false, empty: false, is_exception: false }) }), StructRef(IrTypeStructRef { name: "LocalFirmware", freezed: false, empty: false, is_exception: false }), Optional(IrTypeOptional { inner: Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "Tokens", freezed: false, empty: false, is_exception: false }) }) }), StructRef(IrTypeStructRef { name: "RecordArchive", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "Tokens", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "TransmissionToken", freezed: false, empty: false, is_exception: false }), Primitive(U8), PrimitiveList(IrTypePrimitiveList { primitive: U8 }), Primitive(Usize), StructRef(IrTypeStructRef { name: "WifiTransmissionConfig", freezed: false, empty: false, is_exception: false })]
2023/09/25 13:29:19 [[34mDEBUG[0m] distinct_output_types=[Delegate(Time(Utc)), Delegate(Anyhow), Delegate(String), StructRef(IrTypeStructRef { name: "Authenticated", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "BatteryInfo", freezed: false, empty: false, is_exception: false }), Primitive(Bool), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "DownloadProgress", freezed: false, empty: false, is_exception: false }) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "EphemeralConfig", freezed: false, empty: false, is_exception: false }) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: EnumRef(IrTypeEnumRef { name: "FirmwareDownloadStatus", is_exception: false }) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "SensorValue", freezed: false, empty: false, is_exception: false }) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "StationConfig", freezed: false, empty: false, is_exception: false }) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "TransferProgress", freezed: false, empty: false, is_exception: false }) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "TransmissionConfig", freezed: false, empty: false, is_exception: false }) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: Primitive(U32) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "UpgradeProgress", freezed: false, empty: false, is_exception: false }) }), Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "UploadProgress", freezed: false, empty: false, is_exception: false }) }), StructRef(IrTypeStructRef { name: "DeviceCapabilities", freezed: false, empty: false, is_exception: false }), EnumRef(IrTypeEnumRef { name: "DomainMessage", is_exception: false }), StructRef(IrTypeStructRef { name: "DownloadProgress", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "EphemeralConfig", freezed: false, empty: false, is_exception: false }), Primitive(F32), EnumRef(IrTypeEnumRef { name: "FirmwareDownloadStatus", is_exception: false }), StructRef(IrTypeStructRef { name: "FirmwareInfo", freezed: false, empty: false, is_exception: false }), Primitive(I64), GeneralList(IrTypeGeneralList { inner: StructRef(IrTypeStructRef { name: "LocalFirmware", freezed: false, empty: false, is_exception: false }) }), GeneralList(IrTypeGeneralList { inner: StructRef(IrTypeStructRef { name: "ModuleConfig", freezed: false, empty: false, is_exception: false }) }), GeneralList(IrTypeGeneralList { inner: StructRef(IrTypeStructRef { name: "NearbyStation", freezed: false, empty: false, is_exception: false }) }), GeneralList(IrTypeGeneralList { inner: StructRef(IrTypeStructRef { name: "NetworkConfig", freezed: false, empty: false, is_exception: false }) }), GeneralList(IrTypeGeneralList { inner: StructRef(IrTypeStructRef { name: "RecordArchive", freezed: false, empty: false, is_exception: false }) }), GeneralList(IrTypeGeneralList { inner: StructRef(IrTypeStructRef { name: "SensorConfig", freezed: false, empty: false, is_exception: false }) }), GeneralList(IrTypeGeneralList { inner: StructRef(IrTypeStructRef { name: "StationConfig", freezed: false, empty: false, is_exception: false }) }), StructRef(IrTypeStructRef { name: "LocalFirmware", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "ModuleConfig", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "NearbyStation", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "NetworkConfig", freezed: false, empty: false, is_exception: false }), Optional(IrTypeOptional { inner: Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "EphemeralConfig", freezed: false, empty: false, is_exception: false }) }) }), Optional(IrTypeOptional { inner: Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "SensorValue", freezed: false, empty: false, is_exception: false }) }) }), Optional(IrTypeOptional { inner: Boxed(IrTypeBoxed { exist_in_real_api: false, inner: StructRef(IrTypeStructRef { name: "TransmissionConfig", freezed: false, empty: false, is_exception: false }) }) }), Optional(IrTypeOptional { inner: Boxed(IrTypeBoxed { exist_in_real_api: false, inner: Primitive(U32) }) }), Optional(IrTypeOptional { inner: PrimitiveList(IrTypePrimitiveList { primitive: U8 }) }), StructRef(IrTypeStructRef { name: "RecordArchive", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "SensorConfig", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "SensorValue", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "SolarInfo", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "StationConfig", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "StreamInfo", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "Tokens", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "TransferProgress", freezed: false, empty: false, is_exception: false }), EnumRef(IrTypeEnumRef { name: "TransferStatus", is_exception: false }), StructRef(IrTypeStructRef { name: "TransmissionConfig", freezed: false, empty: false, is_exception: false }), StructRef(IrTypeStructRef { name: "TransmissionToken", freezed: false, empty: false, is_exception: false }), Primitive(U32), Primitive(U64), Primitive(U8), PrimitiveList(IrTypePrimitiveList { primitive: U8 }), Primitive(Unit), StructRef(IrTypeStructRef { name: "UpgradeProgress", freezed: false, empty: false, is_exception: false }), EnumRef(IrTypeEnumRef { name: "UpgradeStatus", is_exception: false }), StructRef(IrTypeStructRef { name: "UploadProgress", freezed: false, empty: false, is_exception: false }), Primitive(Usize)]
2023/09/25 13:29:19 [[32mINFO[0m] Phase: Running build_runner
2023/09/25 13:29:19 [[32mINFO[0m] Running build_runner at /home/kate/Documents/GitLab/patina
2023/09/25 13:29:19 [[34mDEBUG[0m] Guessing toolchain the runner is run into
2023/09/25 13:29:19 [[34mDEBUG[0m] execute command: bin=sh args="-c \"flutter\" \"pub\" \"run\" \"build_runner\" \"build\" \"--delete-conflicting-outputs\" \"--enable-experiment=class-modifiers\"" current_dir=Some("/home/kate/Documents/GitLab/patina") cmd=cd "/home/kate/Documents/GitLab/patina" && "sh" "-c" "\"flutter\" \"pub\" \"run\" \"build_runner\" \"build\" \"--delete-conflicting-outputs\" \"--enable-experiment=class-modifiers\""
2023/09/25 13:29:36 [[34mDEBUG[0m] command=cd "/home/kate/Documents/GitLab/patina" && "sh" "-c" "\"flutter\" \"pub\" \"run\" \"build_runner\" \"build\" \"--delete-conflicting-outputs\" \"--enable-experiment=class-modifiers\"" stdout=[INFO] Generating build script...
[INFO] Generating build script completed, took 220ms

[INFO] Initializing inputs
[INFO] Reading cached asset graph...
[WARNING] Throwing away cached asset graph because the build phases have changed. This most commonly would happen as a result of adding a new dependency or updating your dependencies.
[WARNING] Throwing away cached asset graph because the language version of some package(s) changed. This would most commonly happen when updating dependencies or changing your min sdk constraint.
[INFO] Cleaning up outputs from previous builds....
[INFO] Cleaning up outputs from previous builds. completed, took 5ms

[INFO] Generating build script...
[INFO] Generating build script completed, took 85ms

[WARNING] Invalidated precompiled build script due to missing asset graph.
[INFO] Precompiling build script......
[INFO] Precompiling build script... completed, took 5.3s

[INFO] Initializing inputs
[INFO] Building new asset graph...
[INFO] Building new asset graph completed, took 1.0s

[INFO] Checking for unexpected pre-existing outputs....
[INFO] Checking for unexpected pre-existing outputs. completed, took 0ms

[INFO] Running build...
[INFO] 1.6s elapsed, 41/46 actions completed.
[WARNING] freezed on lib/gen/bridge_definitions.dart:
The class DomainMessage was declared as abstract, but it is not needed anymore.
Read here: https://github.com/rrousselGit/freezed/blob/master/packages/freezed/CHANGELOG.md#0140

[WARNING] freezed on lib/gen/bridge_definitions.dart:
The class FirmwareDownloadStatus was declared as abstract, but it is not needed anymore.
Read here: https://github.com/rrousselGit/freezed/blob/master/packages/freezed/CHANGELOG.md#0140

[WARNING] freezed on lib/gen/bridge_definitions.dart:
The class TransferStatus was declared as abstract, but it is not needed anymore.
Read here: https://github.com/rrousselGit/freezed/blob/master/packages/freezed/CHANGELOG.md#0140

[WARNING] freezed on lib/gen/bridge_definitions.dart:
The class UpgradeStatus was declared as abstract, but it is not needed anymore.
Read here: https://github.com/rrousselGit/freezed/blob/master/packages/freezed/CHANGELOG.md#0140

[WARNING] freezed on lib/bridge_definitions.dart:
The class DomainMessage was declared as abstract, but it is not needed anymore.
Read here: https://github.com/rrousselGit/freezed/blob/master/packages/freezed/CHANGELOG.md#0140

[WARNING] freezed on lib/bridge_definitions.dart:
The class FirmwareDownloadStatus was declared as abstract, but it is not needed anymore.
Read here: https://github.com/rrousselGit/freezed/blob/master/packages/freezed/CHANGELOG.md#0140

[WARNING] freezed on lib/bridge_definitions.dart:
The class TransferStatus was declared as abstract, but it is not needed anymore.
Read here: https://github.com/rrousselGit/freezed/blob/master/packages/freezed/CHANGELOG.md#0140

[WARNING] freezed on lib/bridge_definitions.dart:
The class UpgradeStatus was declared as abstract, but it is not needed anymore.
Read here: https://github.com/rrousselGit/freezed/blob/master/packages/freezed/CHANGELOG.md#0140

[INFO] Running build completed, took 2.5s

[INFO] Caching finalized dependency graph...
[INFO] Caching finalized dependency graph completed, took 65ms

[INFO] Succeeded after 2.5s with 11 outputs (46 actions)

 stderr=
2023/09/25 13:29:36 [[32mINFO[0m] Phase: Formatting Dart code
2023/09/25 13:29:36 [[34mDEBUG[0m] execute format_dart path=["/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.dart", "/home/kate/Documents/GitLab/patina/lib/gen/bridge_definitions.dart", "/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.web.dart", "/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.io.dart", "/home/kate/Documents/GitLab/patina/lib/gen/bridge_definitions.freezed.dart"] line_length=80
2023/09/25 13:29:36 [[34mDEBUG[0m] execute command: bin=sh args="-c \"dart\" \"format\" \"--line-length\" \"80\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_definitions.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.web.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.io.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_definitions.freezed.dart\"" current_dir=None cmd="sh" "-c" "\"dart\" \"format\" \"--line-length\" \"80\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_definitions.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.web.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.io.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_definitions.freezed.dart\""
2023/09/25 13:29:37 [[34mDEBUG[0m] command="sh" "-c" "\"dart\" \"format\" \"--line-length\" \"80\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_definitions.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.web.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.io.dart\" \"/home/kate/Documents/GitLab/patina/lib/gen/bridge_definitions.freezed.dart\"" stdout=Formatted /home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.dart
Formatted /home/kate/Documents/GitLab/patina/lib/gen/bridge_definitions.dart
Formatted /home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.web.dart
Formatted /home/kate/Documents/GitLab/patina/lib/gen/bridge_generated.io.dart
Formatted 5 files (4 changed) in 0.44 seconds.
 stderr=
2023/09/25 13:29:37 [[32mINFO[0m] Success!
2023/09/25 13:29:37 [[32mINFO[0m] Now go and use it :)
